{"version":3,"sources":["../src/index.ts","../src/agent.contract.negotiation.router.ts","../src/Logger.ts","../src/NegotiationService.ts","../src/Profile.ts","../src/Contract.ts","../src/types.ts","../src/DataProvider.ts","../src/Agent.ts","../src/MongoDBProvider.ts","../src/MatchingService.ts","../src/RecommendationService.ts","../src/ContractAgent.ts","../src/ContractAgentHandler.ts","../src/agent.contract.profile.router.ts","../src/ChangeStreamDataProvider.ts","../src/ConsentAgent.ts","../src/ConsentAgentHandler.ts","../src/agent.consent.router.ts","../src/MongooseProvider.ts"],"sourcesContent":["export { default as NegotiationAgentRouter } from './agent.contract.negotiation.router';\r\nexport { default as ContractAgentRouter } from './agent.contract.profile.router';\r\nexport { default as ConsentAgentRouter } from './agent.consent.router';\r\n\r\nexport type {\r\n  ProfilePolicy,\r\n  ProfilePreference,\r\n  ProfileRecommendation,\r\n  ProfileMatching,\r\n  ProfileConfigurations,\r\n  SearchCriteria,\r\n  FilterCondition,\r\n  Provider,\r\n  DataProviderConfig,\r\n  ProfileDocument,\r\n} from './types';\r\n\r\nexport { Profile } from './Profile';\r\nexport { Agent } from './Agent';\r\nexport { Logger } from './Logger';\r\nexport { ContractAgent } from './ContractAgent';\r\nexport { ConsentAgent } from './ConsentAgent';\r\nexport { MongoDBProvider } from './MongoDBProvider';\r\nexport { MongooseProvider } from './MongooseProvider';\r\n","import { Request, Response, Router } from 'express';\r\nimport { NegotiationService } from './NegotiationService';\r\nimport { Profile } from './Profile';\r\nimport { Policy, ServiceOffering, Contract } from './Contract';\r\nimport { ContractAgent } from './ContractAgent';\r\nimport { Logger } from './Logger';\r\nimport { SearchCriteria, FilterOperator } from './types';\r\nimport { Agent } from './Agent';\r\n\r\nconst router: Router = Router();\r\nconst negotiationService = NegotiationService.retrieveService();\r\n\r\nasync function fetchProfileById(profileId: string): Promise<Profile> {\r\n  const criteria: SearchCriteria = {\r\n    conditions: [\r\n      {\r\n        field: 'uri',\r\n        operator: FilterOperator.EQUALS,\r\n        value: profileId,\r\n      },\r\n    ],\r\n    threshold: 0,\r\n  };\r\n  const contractAgent = await ContractAgent.retrieveService();\r\n  const profilesHost = Agent.getProfileHost();\r\n  if (!profilesHost) {\r\n    throw new Error('Fetch Profile by Id: profiles host not set');\r\n  }\r\n  const profiles = await contractAgent.findProfiles(profilesHost, criteria);\r\n  if (profiles.length === 0) {\r\n    throw new Error(`Profile not found for ID: ${profileId}`);\r\n  }\r\n  return new Profile(profiles[0]);\r\n}\r\n\r\n/**\r\n * Handles the request to check if a contract can be accepted by a profile.\r\n * \r\n * @param {Request} req - The incoming request object.\r\n * @param {Response} res - The response object to send back to the client.\r\n */\r\nrouter.post(\r\n  '/negotiation/contract/acceptance',\r\n  async (req: Request, res: Response) => {\r\n    /*    #swagger.tags = ['Negotiation']\r\n          #swagger.requestBody = {\r\n            required: true,\r\n            content: {\r\n                \"application/json\": {\r\n                    schema: {\r\n                        $ref: \"#/components/schemas/ContractPayload\"\r\n                    }  \r\n                }\r\n            }\r\n        } \r\n    */\r\n    try {\r\n      const { profileId, contractData } = req.body;\r\n      const profile = await fetchProfileById(profileId);\r\n      const contract = new Contract(contractData);\r\n      const canAccept = negotiationService.canAcceptContract(profile, contract);\r\n      res.json({ canAccept });\r\n    } catch (error) {\r\n      Logger.error(`Error in contract acceptance check: ${error}`);\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  },\r\n);\r\n\r\n/**\r\n * Handles the request to check if a policy is acceptable by a profile.\r\n * \r\n * @param {Request} req - The incoming request object.\r\n * @param {Response} res - The response object to send back to the client.\r\n */\r\nrouter.post(\r\n  '/negotiation/policy/acceptance',\r\n  async (req: Request, res: Response) => {\r\n    /*    #swagger.tags = ['Negotiation']\r\n          #swagger.requestBody = {\r\n            required: true,\r\n            content: {\r\n                \"application/json\": {\r\n                    schema: {\r\n                        $ref: \"#/components/schemas/PolicyPayload\"\r\n                    }  \r\n                }\r\n            }\r\n        } \r\n    */\r\n    try {\r\n      const { profileId, policyData } = req.body;\r\n      const profile = await fetchProfileById(profileId);\r\n      const policy: Policy = policyData;\r\n      const isAcceptable = negotiationService.isPolicyAcceptable(\r\n        profile,\r\n        policy,\r\n      );\r\n      res.json({ isAcceptable });\r\n    } catch (error) {\r\n      Logger.error(`Error in policy acceptance check: ${error}`);\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  },\r\n);\r\n\r\n/**\r\n * Handles the request to check if a service offering is acceptable by a profile.\r\n * \r\n * @param {Request} req - The incoming request object.\r\n * @param {Response} res - The response object to send back to the client.\r\n */\r\nrouter.post(\r\n  '/negotiation/service/acceptance',\r\n  async (req: Request, res: Response) => {\r\n    /*    #swagger.tags = ['Negotiation']\r\n          #swagger.requestBody = {\r\n            required: true,\r\n            content: {\r\n                \"application/json\": {\r\n                    schema: {\r\n                        $ref: \"#/components/schemas/ServiceOfferingPayload\"\r\n                    }  \r\n                }\r\n            }\r\n        } \r\n    */\r\n    try {\r\n      const { profileId, serviceData } = req.body;\r\n      const profile = await fetchProfileById(profileId);\r\n      const serviceOffering: ServiceOffering = serviceData;\r\n      const isAcceptable = negotiationService.isServiceAcceptable(\r\n        profile,\r\n        serviceOffering,\r\n      );\r\n      res.json({ isAcceptable });\r\n    } catch (error) {\r\n      Logger.error(`Error in service acceptance check: ${error}`);\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  },\r\n);\r\n\r\n/**\r\n * Handles the request to negotiate a contract with a profile.\r\n * \r\n * @param {Request} req - The incoming request object.\r\n * @param {Response} res - The response object to send back to the client.\r\n */\r\nrouter.post(\r\n  '/negotiation/contract/negotiate',\r\n  async (req: Request, res: Response) => {\r\n    /*    #swagger.tags = ['Negotiation']\r\n          #swagger.requestBody = {\r\n            required: true,\r\n            content: {\r\n                \"application/json\": {\r\n                    schema: {\r\n                        $ref: \"#/components/schemas/ContractPayload\"\r\n                    }  \r\n                }\r\n            }\r\n        } \r\n    */\r\n    try {\r\n      const { profileId, contractData } = req.body;\r\n      const profile = await fetchProfileById(profileId);\r\n      const contract = new Contract(contractData);\r\n      const negotiationResult = negotiationService.negotiateContract(\r\n        profile,\r\n        contract,\r\n      );\r\n      res.json(negotiationResult);\r\n    } catch (error) {\r\n      Logger.error(`Error in contract negotiation: ${error}`);\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  },\r\n);\r\n\r\n/**\r\n * Handles the request to update a profile's preferences.\r\n * \r\n * @param {Request} req - The incoming request object.\r\n * @param {Response} res - The response object to send back to the client.\r\n */\r\nrouter.put(\r\n  '/negotiation/profile/preferences',\r\n  async (req: Request, res: Response) => {\r\n    /*    #swagger.tags = ['Negotiation']\r\n          #swagger.requestBody = {\r\n            required: true,\r\n            content: {\r\n                \"application/json\": {\r\n                    schema: {\r\n                        $ref: \"#/components/schemas/ProfilePreferencePayload\"\r\n                    }  \r\n                }\r\n            }\r\n        } \r\n    */\r\n    try {\r\n      const { profileId, preferences } = req.body;\r\n      const profile = await fetchProfileById(profileId);\r\n      negotiationService.updateProfilePreferences(profile, preferences);\r\n      res.json({ message: 'Profile preferences updated successfully.' });\r\n    } catch (error) {\r\n      Logger.error(`Error in updating profile preferences: ${error}`);\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  },\r\n);\r\n\r\nexport default router;\r\n","import { WriteStream, createWriteStream, mkdirSync } from 'fs';\r\nimport { join } from 'path';\r\nimport { format } from 'util';\r\n\r\n/**\r\n * Represents the log levels for the Logger.\r\n * @typedef {'info' | 'warn' | 'error' | 'header'} LogLevel\r\n */\r\ntype LogLevel = 'info' | 'warn' | 'error' | 'header';\r\n\r\n/**\r\n * Configuration options for the Logger.\r\n * @interface LoggerConfig\r\n * @property {boolean} [preserveLogs] - If true, logs will be preserved and passed to an external callback.\r\n * @property {function(LogLevel, string, string): void} [externalCallback] - A callback function to handle preserved logs.\r\n */\r\ninterface LoggerConfig {\r\n  preserveLogs?: boolean;\r\n  externalCallback?: (\r\n    _level: LogLevel,\r\n    _message: string,\r\n    _timestamp: string,\r\n  ) => void;\r\n}\r\n\r\n// ANSI color codes for console output\r\nconst Colors = {\r\n  reset: '\\x1b[0m',\r\n  info: '\\x1b[32m', // green\r\n  warn: '\\x1b[93m', // yellow\r\n  error: '\\x1b[31m', // red\r\n  header: '\\x1b[36m', // cyan\r\n} as const;\r\n\r\n/**\r\n * Logger class for logging messages to the console and optionally to disk.\r\n */\r\nexport class Logger {\r\n  private static noPrint: boolean = false; // Flag to disable console output\r\n\r\n  private static config: LoggerConfig = {\r\n    preserveLogs: false,\r\n  };\r\n\r\n  /**\r\n   * Configures the logger with the provided options.\r\n   * @param {LoggerConfig} config - The configuration settings for the logger.\r\n   */\r\n  static configure(config: LoggerConfig) {\r\n    this.config = { ...this.config, ...config };\r\n  }\r\n\r\n  /**\r\n   * Formats a log message with a timestamp and color based on the log level.\r\n   * @param {LogLevel} level - The log level for the message.\r\n   * @param {string} message - The message to format.\r\n   * @returns {string} - The formatted log message.\r\n   */\r\n  private static formatMessage(level: LogLevel, message: string): string {\r\n    const now = new Date();\r\n    const year = now.getFullYear();\r\n    const month = String(now.getMonth() + 1).padStart(2, '0');\r\n    const day = String(now.getDate()).padStart(2, '0');\r\n    const hours = String(now.getHours()).padStart(2, '0');\r\n    const minutes = String(now.getMinutes()).padStart(2, '0');\r\n    const seconds = String(now.getSeconds()).padStart(2, '0');\r\n    const timestamp = `${year}-${month}-${day}:${hours}.${minutes}.${seconds}`;\r\n    return `${Colors[level]}${timestamp} [${level.toUpperCase()}]: ${message}${Colors.reset}\\n`;\r\n  }\r\n\r\n  /**\r\n   * Logs a message with the specified log level.\r\n   * @param {LogLevel} level - The log level of the message.\r\n   * @param {string} message - The message to log.\r\n   */\r\n  private static log(level: LogLevel, message: string) {\r\n    const timestamp = new Date().toISOString();\r\n    const formattedMessage = this.formatMessage(level, message);\r\n\r\n    if (!this.noPrint) {\r\n      process.stdout.write(formattedMessage);\r\n    }\r\n\r\n    if (this.config.preserveLogs && this.config.externalCallback) {\r\n      this.config.externalCallback(level, message, timestamp);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Logs an informational message.\r\n   * @param {string | object} message - The message to log, can be a string or an object.\r\n   */\r\n  static info(message: string | object) {\r\n    const msg = typeof message === 'string' ? message : format(message);\r\n    this.log('info', msg);\r\n  }\r\n\r\n  /**\r\n   * Logs a warning message.\r\n   * @param {string | object} message - The message to log, can be a string or an object.\r\n   */\r\n  static warn(message: string | object) {\r\n    const msg = typeof message === 'string' ? message : format(message);\r\n    this.log('warn', msg);\r\n  }\r\n\r\n  /**\r\n   * Logs an error message.\r\n   * @param {string | object} message - The message to log, can be a string or an object.\r\n   */\r\n  static error(message: string | object) {\r\n    const msg = typeof message === 'string' ? message : format(message);\r\n    this.log('error', msg);\r\n  }\r\n\r\n  /**\r\n   * Logs a header message.\r\n   * @param {string | object} message - The message to log, can be a string or an object.\r\n   */\r\n  static header(message: string | object) {\r\n    const msg = typeof message === 'string' ? message : format(message);\r\n    this.log('header', msg);\r\n  }\r\n}\r\n\r\n// Default log path for disk logging\r\nconst DEFAULT_LOG_PATH = join(process.cwd(), 'logs');\r\nlet logStream: WriteStream;\r\n\r\n/**\r\n * Generates a log file name based on the current timestamp.\r\n * @returns {string} - The generated log file name.\r\n */\r\nconst getLogFileName = () => {\r\n  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\r\n  return `cca-${timestamp}.log`;\r\n};\r\n\r\n/**\r\n * Initializes the disk logger by creating the log directory and file.\r\n * @returns {boolean} - True if the logger was successfully initialized, otherwise false.\r\n */\r\nconst initDiskLogger = () => {\r\n  try {\r\n    mkdirSync(DEFAULT_LOG_PATH, { recursive: true });\r\n    const logFile = join(DEFAULT_LOG_PATH, getLogFileName());\r\n    logStream = createWriteStream(logFile, { flags: 'a' });\r\n    return true;\r\n  } catch (err) {\r\n    process.stderr.write(`Failed to create log directory: ${err}\\n`);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Default callback function for handling logs that should be preserved.\r\n * @param {LogLevel} level - The log level of the message.\r\n * @param {string} message - The message to log.\r\n * @param {string} timestamp - The timestamp of the log message.\r\n */\r\nconst defaultDiskCallback = (\r\n  level: LogLevel,\r\n  message: string,\r\n  timestamp: string,\r\n) => {\r\n  if (!logStream && !initDiskLogger()) {\r\n    return;\r\n  }\r\n  const plainMessage = `${timestamp} [LOGGER][${level.toUpperCase()}]: ${message}\\n`;\r\n  logStream.write(plainMessage);\r\n};\r\n\r\n// Initial configuration of the logger to preserve logs on disk\r\nLogger.configure({\r\n  preserveLogs: true,\r\n  externalCallback: defaultDiskCallback,\r\n});\r\n","import { Profile } from './Profile';\r\nimport { ProfilePreference } from './types';\r\nimport { Contract, Policy, ServiceOffering } from './Contract';\r\nimport { Logger } from './Logger';\r\n\r\nexport class NegotiationService {\r\n  private static instance: NegotiationService;\r\n\r\n  static retrieveService(refresh: boolean = false): NegotiationService {\r\n    if (!NegotiationService.instance || refresh) {\r\n      const instance = new NegotiationService();\r\n      NegotiationService.instance = instance;\r\n    }\r\n    return NegotiationService.instance;\r\n  }\r\n\r\n  /**\r\n   * Checks if a policy is acceptable based on the profile preferences.\r\n   * A policy is acceptable if it matches a profile's allowed policies\r\n   * and has a frequency greater than 0.\r\n   *\r\n   * @param {Profile} profile - The profile to evaluate.\r\n   * @param {Policy} policy - The policy to check.\r\n   * @returns {boolean} - True if acceptable, otherwise false.\r\n   */\r\n  isPolicyAcceptable(profile: Profile, policy: Policy): boolean {\r\n    if (profile?.configurations?.allowPolicies === false) {\r\n      Logger.info('Policies are not allowed by the profile configurations.');\r\n      return false;\r\n    }\r\n    return profile.preference.some((pref) =>\r\n      pref.policies.some(\r\n        (p) => p.policy === policy.description && p.frequency > 0,\r\n      ),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Checks if a service offering is acceptable based on the profile preferences.\r\n   *\r\n   * @param {Profile} profile - The profile to evaluate.\r\n   * @param {ServiceOffering} serviceOffering - The service offering to check.\r\n   * @returns {boolean} - True if acceptable, otherwise false.\r\n   */\r\n  isServiceAcceptable(\r\n    profile: Profile,\r\n    serviceOffering: ServiceOffering,\r\n  ): boolean {\r\n    return profile.preference.some((pref) =>\r\n      pref.services.includes(serviceOffering.serviceOffering),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Validates if all policies of a service offering are acceptable.\r\n   * A service offering is considered acceptable if:\r\n   * - The service is acceptable to the profile.\r\n   * - All its policies are acceptable to the profile.\r\n   *\r\n   * @param {Profile} profile - The profile to evaluate.\r\n   * @param {ServiceOffering} serviceOffering - The service offering to check.\r\n   * @returns {boolean} - True if acceptable, otherwise false.\r\n   */\r\n  areServicePoliciesAcceptable(\r\n    profile: Profile,\r\n    serviceOffering: ServiceOffering,\r\n  ): boolean {\r\n    return (\r\n      this.isServiceAcceptable(profile, serviceOffering) &&\r\n      serviceOffering.policies.every((policy) =>\r\n        this.isPolicyAcceptable(profile, policy),\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Determines if a contract can be accepted by the profile.\r\n   * A contract is acceptable if:\r\n   * - Its status is 'active' or 'signed'.\r\n   * - All its service offerings and their policies are acceptable.\r\n   *\r\n   * @param {Profile} profile - The profile to evaluate.\r\n   * @param {Contract} contract - The contract to evaluate.\r\n   * @returns {boolean} - True if acceptable, otherwise false.\r\n   */\r\n  canAcceptContract(profile: Profile, contract: Contract): boolean {\r\n    if (contract.status !== 'active' && contract.status !== 'signed') {\r\n      Logger.info('Contract is not active.');\r\n      return false;\r\n    }\r\n    const acceptableServices = contract.serviceOfferings.every(\r\n      (serviceOffering) =>\r\n        this.areServicePoliciesAcceptable(profile, serviceOffering),\r\n    );\r\n    return acceptableServices;\r\n  }\r\n\r\n  /**\r\n   * Updates a profile's preferences by adding new valid preferences.\r\n   * Valid preferences must:\r\n   * - Be neither undefined nor null.\r\n   * - Have policies, services, and ecosystems as arrays.\r\n   */\r\n  updateProfilePreferences(\r\n    profile: Profile,\r\n    preferences: Partial<ProfilePreference>[],\r\n  ): void {\r\n    try {\r\n      const validPreferences = preferences.filter(\r\n        (pref): pref is ProfilePreference =>\r\n          pref !== undefined &&\r\n          pref !== null &&\r\n          Array.isArray(pref.policies) &&\r\n          Array.isArray(pref.services) &&\r\n          Array.isArray(pref.ecosystems),\r\n      );\r\n      profile.preference = [...profile.preference, ...validPreferences];\r\n      Logger.info(`Profile preferences updated for ${profile.uri}.`);\r\n    } catch (error) {\r\n      Logger.error(`Failed to update profile preferences: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Negotiates a contract by checking its compatibility with the profile.\r\n   * Returns detailed information about the acceptability of the contract.\r\n   *\r\n   * @param {Profile} profile - The profile to evaluate.\r\n   * @param {Contract} contract - The contract to negotiate.\r\n   * @returns {object} - Details about contract acceptability.\r\n   */\r\n  negotiateContract(\r\n    profile: Profile,\r\n    contract: Contract,\r\n  ): {\r\n    canAccept: boolean;\r\n    reason?: string;\r\n    unacceptablePolicies?: string[];\r\n    unacceptableServices?: string[];\r\n  } {\r\n    try {\r\n      const unacceptablePolicies: string[] = [];\r\n      const unacceptableServices: string[] = [];\r\n      contract.serviceOfferings.forEach((serviceOffering) => {\r\n        if (!this.isServiceAcceptable(profile, serviceOffering)) {\r\n          unacceptableServices.push(serviceOffering.serviceOffering);\r\n        }\r\n        serviceOffering.policies.forEach((policy) => {\r\n          if (!this.isPolicyAcceptable(profile, policy)) {\r\n            unacceptablePolicies.push(policy.description);\r\n          }\r\n        });\r\n      });\r\n      if (unacceptablePolicies.length > 0 || unacceptableServices.length > 0) {\r\n        return {\r\n          canAccept: false,\r\n          reason: 'Contract contains unacceptable policies or services',\r\n          unacceptablePolicies,\r\n          unacceptableServices,\r\n        };\r\n      }\r\n      if (!this.canAcceptContract(profile, contract)) {\r\n        return {\r\n          canAccept: false,\r\n          reason: 'Contract does not align with profile preferences',\r\n        };\r\n      }\r\n      return { canAccept: true };\r\n    } catch (error) {\r\n      Logger.error(`Negotiation failed: ${error}`);\r\n      return {\r\n        canAccept: false,\r\n        reason: 'An error occurred during negotiation.',\r\n      };\r\n    }\r\n  }\r\n}\r\n","import mongoose, { Schema, Document } from 'mongoose';\r\nimport {\r\n  ProfileConfigurations,\r\n  ProfileRecommendation,\r\n  ProfilePreference,\r\n  ProfileMatching,\r\n  ConsentProfileRecommendation,\r\n} from './types';\r\n\r\nexport type ProfileJSON = Omit<\r\n  Pick<Profile, keyof Profile>,\r\n  'createdAt' | 'updatedAt'\r\n> & {\r\n  createdAt?: string | Date;\r\n  updatedAt?: string | Date;\r\n};\r\n\r\nexport class Profile {\r\n  _id?: string;\r\n  uri?: string;\r\n  configurations: ProfileConfigurations;\r\n  recommendations: ProfileRecommendation[] | ConsentProfileRecommendation;\r\n  matching: ProfileMatching[];\r\n  preference: ProfilePreference[];\r\n\r\n  constructor({\r\n    _id,\r\n    uri,\r\n    configurations,\r\n    recommendations,\r\n    matching = [],\r\n    preference = [],\r\n  }: ProfileJSON) {\r\n    this._id = _id;\r\n    this.uri = uri;\r\n    this.configurations = configurations;\r\n    this.recommendations = recommendations;\r\n    this.matching = matching;\r\n    this.preference = preference;\r\n  }\r\n}\r\n\r\nexport const ProfileSchema = new Schema(\r\n  {\r\n    uri: { type: String, required: true },\r\n    configurations: { type: Schema.Types.Mixed, required: true },\r\n    recommendations: { type: [Schema.Types.Mixed], default: [] },\r\n    matching: { type: [Schema.Types.Mixed], default: [] },\r\n    preference: { type: [Schema.Types.Mixed], default: [] },\r\n  },\r\n  {\r\n    timestamps: true,\r\n  },\r\n);\r\n\r\nexport const ProfileModel = mongoose.model<Document & Profile>(\r\n  'Profile',\r\n  ProfileSchema,\r\n);\r\n","export interface Participant {\r\n  participant: string;\r\n  role: string;\r\n  signature: string;\r\n  date: string;\r\n}\r\n\r\nexport interface Policy {\r\n  description: string;\r\n  permission: {\r\n    action: string;\r\n    target: string;\r\n    constraint: {\r\n      leftOperand: string;\r\n      operator: string;\r\n      rightOperand: number | string;\r\n    }[];\r\n  }[];\r\n  prohibition: any[];\r\n}\r\n\r\nexport interface ServiceOffering {\r\n  participant: string;\r\n  serviceOffering: string;\r\n  policies: Policy[];\r\n  _id?: string;\r\n}\r\n\r\nexport type ContractJSON = Omit<\r\n  Pick<Contract, keyof Contract>,\r\n  'createdAt' | 'updatedAt'\r\n> & {\r\n  createdAt: string | Date;\r\n  updatedAt: string | Date;\r\n};\r\n\r\nexport class Contract {\r\n  _id?: string;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n  ecosystem: string;\r\n  members: Participant[];\r\n  orchestrator: string;\r\n  purpose: string[];\r\n  revokedMembers: Participant[];\r\n  rolesAndObligations: any[];\r\n  serviceOfferings: ServiceOffering[];\r\n  status: string;\r\n\r\n  constructor({\r\n    createdAt,\r\n    updatedAt,\r\n    ecosystem,\r\n    members,\r\n    orchestrator,\r\n    purpose,\r\n    revokedMembers,\r\n    rolesAndObligations,\r\n    serviceOfferings,\r\n    status,\r\n    _id,\r\n  }: ContractJSON) {\r\n    this._id = _id;\r\n    this.createdAt = new Date(createdAt);\r\n    this.updatedAt = new Date(updatedAt);\r\n    this.ecosystem = ecosystem;\r\n    this.members = members;\r\n    this.orchestrator = orchestrator;\r\n    this.purpose = purpose;\r\n    this.revokedMembers = revokedMembers;\r\n    this.rolesAndObligations = rolesAndObligations;\r\n    this.serviceOfferings = serviceOfferings;\r\n    this.status = status;\r\n  }\r\n}\r\n","import { DataProvider } from './DataProvider';\r\n\r\nexport interface ProfilePolicy {\r\n  policy: string;\r\n  frequency: number;\r\n}\r\n\r\nexport interface ProfilePreference {\r\n  _id?: string;\r\n  policies: ProfilePolicy[];\r\n  ecosystems: string[];\r\n  services: string[];\r\n  participant?: string;\r\n  category?: string;\r\n  asDataProvider?: {\r\n    authorizationLevel?: AuthorizationLevelEnum,\r\n    conditions?: Condition[]\r\n  };\r\n  asServiceProvider?: {\r\n    authorizationLevel?: AuthorizationLevelEnum,\r\n    conditions?: Condition[]\r\n  };\r\n}\r\n\r\nexport interface ProfileRecommendation {\r\n  policies?: ProfilePolicy[];\r\n  ecosystemContracts?: any[];\r\n  services?: any[];\r\n  consents?: any[];\r\n  dataExchanges?: any[];\r\n}\r\n\r\nexport interface ConsentProfileRecommendation {\r\n  consents?: any[];\r\n  dataExchanges?: any[];\r\n}\r\n\r\nexport interface ProfileMatching {\r\n  policies: ProfilePolicy[];\r\n  ecosystemContracts: any[];\r\n  services: any[];\r\n}\r\n\r\nexport interface ProfileConfigurations {\r\n  allowRecommendations?: boolean;\r\n  allowPolicies?: boolean;\r\n}\r\n\r\nexport interface SearchCriteria {\r\n  conditions: FilterCondition[];\r\n  threshold: number;\r\n  limit?: number;\r\n}\r\n\r\nexport interface FilterCondition {\r\n  field: string;\r\n  operator: FilterOperator;\r\n  value: any;\r\n}\r\n\r\nexport enum FilterOperator {\r\n  IN = 'IN',\r\n  EQUALS = 'EQUALS',\r\n  GT = 'GT',\r\n  LT = 'LT',\r\n  CONTAINS = 'CONTAINS',\r\n  REGEX = 'REGEX',\r\n}\r\n\r\nexport interface Provider {\r\n  source?: string;\r\n  watchChanges?: boolean;\r\n  provider: DataProvider;\r\n  hostsProfiles?: boolean;\r\n}\r\n\r\nexport interface DataProviderConfig {\r\n  source: string;\r\n  url: string;\r\n  dbName: string;\r\n  watchChanges?: boolean;\r\n  hostsProfiles?: boolean;\r\n}\r\n\r\nexport interface ProfileDocument {\r\n  _id?: string;\r\n  uri?: string;\r\n  configurations: any;\r\n  recommendations?: any[] | ConsentProfileRecommendation;\r\n  matching?: any[];\r\n  preference?: any[];\r\n}\r\n\r\nexport interface ProfilePayload {\r\n  configurations?: any;\r\n  recommendations?: any[];\r\n  matching?: any[];\r\n  preference?: any[];\r\n}\r\n\r\nexport namespace CAECode {\r\n  export type Type =\r\n    | 'SERVICE_RETRIEVAL_FAILED'\r\n    | 'PREPARATION_FAILED'\r\n    | 'PROFILE_SEARCH_FAILED'\r\n    | 'PROFILE_SAVE_FAILED';\r\n  export const SERVICE_RETRIEVAL_FAILED: Type = 'SERVICE_RETRIEVAL_FAILED';\r\n  export const PREPARATION_FAILED: Type = 'PREPARATION_FAILED';\r\n  export const PROFILE_SEARCH_FAILED: Type = 'PROFILE_SEARCH_FAILED';\r\n  export const PROFILE_SAVE_FAILED: Type = 'PROFILE_SAVE_FAILED';\r\n}\r\n\r\nexport interface ContractAgentError extends Error {\r\n  code: CAECode.Type;\r\n  context?: unknown;\r\n}\r\n\r\nexport interface ConsentAgentError extends Error {\r\n  code: CAECode.Type;\r\n  context?: unknown;\r\n}\r\n\r\nexport interface DataProviderResult<T> {\r\n  success: boolean;\r\n  data?: T;\r\n  error?: ContractAgentError;\r\n}\r\n\r\nexport interface ProfileUpdateResult {\r\n  success: boolean;\r\n  profileId: string;\r\n  error?: ContractAgentError;\r\n}\r\n\r\nexport type DataChangeEvent = {\r\n  source: string;\r\n  type: 'insert' | 'update' | 'delete';\r\n  documentKey?: { _id: string };\r\n  fullDocument?: unknown;\r\n  updateDescription?: {\r\n    updatedFields: unknown;\r\n    removedFields?: string[];\r\n  };\r\n};\r\n\r\nexport type PreferencePayload = {\r\n  participant: string,\r\n  category: string,\r\n  asDataProvider: {\r\n    authorizationLevel?: AuthorizationLevelEnum,\r\n    conditions?: Condition[]\r\n  };\r\n  asServiceProvider: {\r\n    authorizationLevel?: AuthorizationLevelEnum,\r\n    conditions?: Condition[]\r\n  };\r\n}\r\n\r\nexport type Condition = {\r\n  time?: TimeCondition,\r\n  location?: LocationCondition\r\n}\r\n\r\nexport type TimeCondition = {\r\n  dayOfWeek?: string[],\r\n  startTime?: string,\r\n  endTime?: string,\r\n}\r\n\r\nexport type LocationCondition = {\r\n  countryCode: string\r\n}\r\n\r\nexport enum AuthorizationLevelEnum {\r\n  NEVER = 'never',\r\n  ALWAYS = 'always',\r\n  CONDITIONAL = 'conditional',\r\n}\r\n","import { EventEmitter } from 'events';\r\nimport { FilterCondition, SearchCriteria } from './types';\r\n\r\nexport type DataProviderType = { new (...args: any[]): DataProvider };\r\n\r\nexport abstract class DataProvider extends EventEmitter {\r\n  static childType?: DataProviderType;\r\n\r\n  // eslint-disable-next-line no-unused-vars\r\n  constructor(public dataSource: string) {\r\n    super();\r\n  }\r\n  //\r\n\r\n  // eslint-disable-next-line no-unused-vars\r\n  abstract find(criteria: SearchCriteria): Promise<[]>;\r\n  abstract findAll(): Promise<any[]>;\r\n  // eslint-disable-next-line no-unused-vars\r\n  abstract findOne(criteria: SearchCriteria): Promise<any>;\r\n  // eslint-disable-next-line no-unused-vars\r\n  abstract findOneAndUpdate(criteria: SearchCriteria, data: any): Promise<any>;\r\n  // eslint-disable-next-line no-unused-vars\r\n  abstract findOneAndPush(criteria: SearchCriteria, data: any): Promise<any>;\r\n  // eslint-disable-next-line no-unused-vars\r\n  abstract findOneAndPull(criteria: SearchCriteria, data: any): Promise<any>;\r\n  // eslint-disable-next-line no-unused-vars\r\n  abstract create(data: unknown): Promise<unknown>;\r\n  // eslint-disable-next-line no-unused-vars\r\n  abstract delete(id: string): Promise<boolean>;\r\n  // eslint-disable-next-line no-unused-vars\r\n  abstract update(criteria: SearchCriteria, data: unknown): Promise<boolean>;\r\n\r\n  static setChildType(childType: DataProviderType) {\r\n    DataProvider.childType = childType;\r\n  }\r\n\r\n  static getChildType(): DataProviderType | undefined {\r\n    return DataProvider.childType;\r\n  }\r\n\r\n  createInstance(): DataProvider {\r\n    if (!DataProvider.childType) {\r\n      throw new Error('Child type not linked');\r\n    }\r\n    return new DataProvider.childType();\r\n  }\r\n\r\n  async ensureReady(): Promise<void> {}\r\n\r\n  protected abstract makeQuery(\r\n    // eslint-disable-next-line no-unused-vars\r\n    conditions: FilterCondition[],\r\n  ): Record<string, any>;\r\n\r\n  //\r\n  protected notifyDataChange(eventName: string, data: any): void {\r\n    this.emit(eventName, data);\r\n  }\r\n}\r\n","import { Profile, ProfileJSON } from './Profile';\r\nimport { DataProvider } from './DataProvider';\r\nimport * as fs from 'fs';\r\nimport { Logger } from './Logger';\r\nimport {\r\n  SearchCriteria,\r\n  ProfileRecommendation,\r\n  ProfileMatching,\r\n  Provider,\r\n  DataProviderConfig,\r\n  DataChangeEvent,\r\n  ProfileDocument,\r\n  ContractAgentError,\r\n  CAECode,\r\n  FilterOperator,\r\n  ConsentProfileRecommendation,\r\n} from './types';\r\nimport path from 'path';\r\n\r\nexport interface AgentConfig {\r\n  existingDataCheck?: boolean;\r\n  dataProviderConfig: DataProviderConfig[];\r\n}\r\n\r\nexport abstract class Agent {\r\n  protected static configPath: string;\r\n  protected static profilesHost: string;\r\n  protected config?: AgentConfig;\r\n  protected dataProviders: Provider[] = [];\r\n\r\n  protected constructor() {\r\n    if (!Agent.configPath) {\r\n      throw new Error('Config path not set');\r\n    }\r\n  }\r\n\r\n  static setProfilesHost(profilesHost: string) {\r\n    Agent.profilesHost = profilesHost;\r\n    if (!Agent.profilesHost) {\r\n      Logger.warn('using default profiles source');\r\n      Agent.profilesHost = 'profiles';\r\n    }\r\n  }\r\n\r\n  static getProfileHost(): string {\r\n    return Agent.profilesHost;\r\n  }\r\n\r\n  static setConfigPath(configPath: string, callerFilePath: string): void {\r\n    const fileDir = path.dirname(callerFilePath);\r\n    const agentConfigPath = path.join(fileDir, configPath);\r\n    Agent.configPath = agentConfigPath;\r\n  }\r\n\r\n  protected setupProviderEventHandlers(): void {\r\n    this.dataProviders.forEach(({ provider, watchChanges }) => {\r\n      if (watchChanges !== false) {\r\n        provider.on('dataInserted', this.handleDataInserted.bind(this));\r\n        provider.on('dataUpdated', this.handleDataUpdated.bind(this));\r\n        provider.on('dataDeleted', this.handleDataDeleted.bind(this));\r\n      }\r\n    });\r\n  }\r\n\r\n  getDataProvider(source: string): DataProvider {\r\n    const dataProvider = this.dataProviders.find(\r\n      (provider) => provider.source === source,\r\n    )?.provider;\r\n    if (!dataProvider) {\r\n      throw new Error(`DataProvider for source '${source}' not found.`);\r\n    }\r\n    return dataProvider;\r\n  }\r\n\r\n  // eslint-disable-next-line no-unused-vars\r\n  protected abstract handleDataInserted(data: DataChangeEvent): Promise<void>;\r\n  // eslint-disable-next-line no-unused-vars\r\n  protected abstract handleDataUpdated(data: DataChangeEvent): Promise<void>;\r\n  // eslint-disable-next-line no-unused-vars\r\n  protected abstract handleDataDeleted(data: DataChangeEvent): void;\r\n\r\n  abstract findProfiles(\r\n    // eslint-disable-next-line no-unused-vars\r\n    source: string,\r\n    // eslint-disable-next-line no-unused-vars\r\n    criteria: SearchCriteria,\r\n  ): Promise<Profile[]>;\r\n\r\n  protected abstract existingDataCheck(): Promise<void>;\r\n\r\n  addDataProviders(dataProviders: Provider[]): void {\r\n    if (!dataProviders || dataProviders.length === 0) {\r\n      throw new Error('The dataProviders array cannot be empty.');\r\n    }\r\n    for (const dataProvider of dataProviders) {\r\n      if (!dataProvider.provider) {\r\n        continue;\r\n      }\r\n      dataProvider.source = dataProvider.provider.dataSource;\r\n      if (dataProvider.hostsProfiles && dataProvider.source) {\r\n        Agent.setProfilesHost(dataProvider.source);\r\n      }\r\n    }\r\n    this.dataProviders.push(...dataProviders);\r\n  }\r\n\r\n  protected async addDefaultProviders(): Promise<void> {\r\n    if (!this.config) {\r\n      Logger.warn('No configuration found. No data providers added.');\r\n      return;\r\n    }\r\n    const providerType = DataProvider.childType;\r\n    if (typeof providerType !== 'function') {\r\n      throw new Error('Invalid DataProvider type');\r\n    }\r\n    for (const dpConfig of this.config.dataProviderConfig) {\r\n      try {\r\n        const provider = new providerType(dpConfig);\r\n        await provider.ensureReady();\r\n        const { watchChanges, source, hostsProfiles } = dpConfig;\r\n        this.addDataProviders([\r\n          {\r\n            watchChanges,\r\n            source,\r\n            provider,\r\n            hostsProfiles,\r\n          },\r\n        ]);\r\n      } catch (error) {\r\n        Logger.error(\r\n          `Failed to add data provider for source ${dpConfig.source}: ${(error as Error).message}`,\r\n        );\r\n      }\r\n    }\r\n    if(this.config.existingDataCheck){\r\n      await this.existingDataCheck();\r\n    }\r\n  }\r\n\r\n  protected loadDefaultConfiguration(): void {\r\n    try {\r\n      const configData = fs.readFileSync(Agent.configPath, 'utf-8');\r\n      this.config = JSON.parse(configData) as AgentConfig;\r\n      Logger.info('Configuration loaded successfully');\r\n    } catch (error) {\r\n      Logger.error(`Failed to load configuration: ${(error as Error).message}`);\r\n      this.config = { dataProviderConfig: [] };\r\n    }\r\n  }\r\n\r\n  getRecommendations(profile: Profile): ProfileRecommendation[] | ConsentProfileRecommendation {\r\n    return profile.recommendations;\r\n  }\r\n\r\n  getMatchings(profile: Profile): ProfileMatching[] {\r\n    return profile.matching;\r\n  }\r\n\r\n  abstract saveProfile(\r\n    source: string,\r\n    criteria: SearchCriteria,\r\n    profile: Profile,\r\n  ): Promise<boolean>;\r\n\r\n  protected async createProfileForParticipant(\r\n    participantId: string,\r\n  ): Promise<Profile> {\r\n    try {\r\n      if (!Agent.profilesHost) {\r\n        throw new Error(\r\n          `Can't create profile for participant \"profilesHost\" is not set`,\r\n        );\r\n      }\r\n      const profileProvider = this.getDataProvider(Agent.profilesHost);\r\n      const newProfileData = {\r\n        uri: participantId,\r\n        configurations: {},\r\n        recommendations: [] as unknown,\r\n        matching: [] as unknown,\r\n      };\r\n      const profile = await profileProvider.create(newProfileData);\r\n      return new Profile(profile as ProfileJSON);\r\n    } catch (error) {\r\n      Logger.error(`Error creating profile: ${(error as Error).message}`);\r\n      throw new Error('Profile creation failed');\r\n    }\r\n  }\r\n\r\n  protected abstract updateMatchingForProfile(\r\n    // eslint-disable-next-line no-unused-vars\r\n    profile: Profile,\r\n    // eslint-disable-next-line no-unused-vars\r\n    data: unknown,\r\n  ): Promise<void>;\r\n\r\n  protected abstract updateRecommendationForProfile(\r\n    // eslint-disable-next-line no-unused-vars\r\n    profile: Profile,\r\n    // eslint-disable-next-line no-unused-vars\r\n    data: unknown,\r\n  ): Promise<void>;\r\n\r\n  protected abstract enrichProfileWithSystemRecommendations(): Profile;\r\n}\r\n","import {\r\n  Collection,\r\n  Db,\r\n  Document,\r\n  WithId,\r\n  InsertOneResult,\r\n  MongoClient,\r\n  ObjectId,\r\n  MatchKeysAndValues,\r\n} from 'mongodb';\r\nimport { DataProvider } from './DataProvider';\r\nimport { DataProviderConfig, FilterCondition, FilterOperator, SearchCriteria } from './types';\r\nimport { Logger } from './Logger';\r\n\r\ntype DocumentChangeHandler = (collectionName: string, document: any) => void;\r\n\r\nclass MongoInterceptor {\r\n  private static instance: MongoInterceptor;\r\n  private callbacks: Map<string, DocumentChangeHandler[]>;\r\n\r\n  private constructor() {\r\n    this.callbacks = new Map();\r\n    ['insert', 'update', 'delete'].forEach((op) => {\r\n      this.callbacks.set(op, []);\r\n    });\r\n  }\r\n\r\n  static getInstance(): MongoInterceptor {\r\n    if (!MongoInterceptor.instance) {\r\n      MongoInterceptor.instance = new MongoInterceptor();\r\n    }\r\n    return MongoInterceptor.instance;\r\n  }\r\n\r\n  public addCallback(\r\n    changeType: string,\r\n    callback: DocumentChangeHandler,\r\n  ): void {\r\n    const callbacks = this.callbacks.get(changeType) || [];\r\n    callbacks.push(callback);\r\n    this.callbacks.set(changeType, callbacks);\r\n  }\r\n\r\n  public notifyCallbacks(\r\n    changeType: string,\r\n    collectionName: string,\r\n    document: any,\r\n  ): void {\r\n    const callbacks = this.callbacks.get(changeType) || [];\r\n    callbacks.forEach((callback) => callback(collectionName, document));\r\n  }\r\n}\r\n\r\nexport class MongoDBProvider extends DataProvider {\r\n  findAll(): Promise<any[]> {\r\n    throw new Error('Method not implemented.');\r\n  }\r\n  private static connections: Map<\r\n    string,\r\n    { db: Db; client: MongoClient } | undefined\r\n  > = new Map();\r\n  private db?: Db;\r\n  private client?: MongoClient;\r\n  private collection!: Collection<Document>;\r\n  private dbName: string;\r\n  private connectionPromise?: Promise<Db>;\r\n\r\n  constructor(config: DataProviderConfig) {\r\n    super(config.source);\r\n    this.dbName = config.dbName;\r\n    this.connectionPromise = this.connectToDatabase(config.url);\r\n  }\r\n\r\n  getClient(): MongoClient | undefined {\r\n    return this.client;\r\n  }\r\n\r\n  getCollection(): Collection<Document> {\r\n    return this.collection;\r\n  }\r\n\r\n  private async connectToDatabase(url: string): Promise<Db> {\r\n    if (!url) {\r\n      throw new Error('Database URL is required');\r\n    }\r\n    const connectionKey = `${url}:${this.dbName}`;\r\n    const existingConnection = MongoDBProvider.connections.get(connectionKey);\r\n    if (existingConnection) {\r\n      Logger.info('Reusing existing MongoDB connection');\r\n      this.db = existingConnection.db;\r\n      this.client = existingConnection.client;\r\n      return this.db;\r\n    }\r\n\r\n    try {\r\n      const client = await MongoClient.connect(url);\r\n      const db = client.db(this.dbName);\r\n\r\n      Logger.info('MongoDB connected successfully');\r\n      this.db = db;\r\n      this.client = client;\r\n\r\n      MongoDBProvider.connections.set(connectionKey, { db, client });\r\n      return db;\r\n    } catch (error) {\r\n      Logger.error(`Error connecting to MongoDB: ${(error as Error).message}`);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public static async disconnectFromDatabase(\r\n    url: string,\r\n    dbName: string,\r\n  ): Promise<void> {\r\n    const connectionKey = `${url}:${dbName}`;\r\n    const existingConnection = MongoDBProvider.connections.get(connectionKey);\r\n\r\n    if (existingConnection) {\r\n      try {\r\n        await existingConnection.client.close();\r\n        MongoDBProvider.connections.set(connectionKey, undefined);\r\n        Logger.info(`MongoDB connection for ${connectionKey} closed`);\r\n      } catch (error) {\r\n        Logger.error(`Error during disconnect: ${(error as Error).message}`);\r\n      }\r\n    } else {\r\n      Logger.warn(`No active connection found for ${connectionKey}`);\r\n    }\r\n  }\r\n\r\n  async ensureReady(collection?: Collection<Document>): Promise<void> {\r\n    await this.connectionPromise;\r\n    this.collection = MongoDBProvider.createCollectionProxy(\r\n      collection || this.db!.collection(this.dataSource),\r\n    );\r\n    this.setupCallbacks();\r\n  }\r\n\r\n  private static createCollectionProxy(collection: Collection): Collection {\r\n    const interceptor = MongoInterceptor.getInstance();\r\n\r\n    const handler = {\r\n      get(target: Collection, prop: string | symbol): any {\r\n        const original = target[prop as keyof Collection];\r\n        if (typeof original !== 'function') return original;\r\n        const cursorMethods = ['find', 'aggregate'];\r\n        if (cursorMethods.includes(prop as string)) {\r\n          return function (this: Collection, ...args: any[]) {\r\n            return (original as Function).call(target, ...args);\r\n          };\r\n        }\r\n        return async function (this: any, ...args: any[]) {\r\n          const method = original as (...args: any[]) => Promise<any>;\r\n          const result = await method.apply(target, args);\r\n          if (['insertOne', 'save'].includes(prop as string)) {\r\n            interceptor.notifyCallbacks('insert', collection.collectionName, {\r\n              fullDocument: args[0],\r\n              insertedId: result.insertedId,\r\n              acknowledged: result.acknowledged,\r\n            });\r\n          } else if (prop === 'insertMany') {\r\n            interceptor.notifyCallbacks('insert', collection.collectionName, {\r\n              fullDocuments: args[0],\r\n              insertedIds: result.insertedIds,\r\n              acknowledged: result.acknowledged,\r\n            });\r\n          } else if (\r\n            [\r\n              'updateOne',\r\n              'updateMany',\r\n              'replaceOne',\r\n              'findOneAndUpdate',\r\n              'findOneAndReplace',\r\n            ].includes(prop as string)\r\n          ) {\r\n            interceptor.notifyCallbacks('update', collection.collectionName, {\r\n              filter: args[0],\r\n              update: args[1],\r\n              options: args[2],\r\n              result,\r\n            });\r\n          } else if (prop === 'bulkWrite') {\r\n            const operations = args[0];\r\n            operations.forEach((op: any) => {\r\n              if (op.insertOne) {\r\n                interceptor.notifyCallbacks(\r\n                  'insert',\r\n                  collection.collectionName,\r\n                  {\r\n                    fullDocument: op.insertOne.document,\r\n                    result,\r\n                  },\r\n                );\r\n              } else if (op.updateOne || op.updateMany) {\r\n                interceptor.notifyCallbacks(\r\n                  'update',\r\n                  collection.collectionName,\r\n                  {\r\n                    filter: op.updateOne?.filter || op.updateMany?.filter,\r\n                    update: op.updateOne?.update || op.updateMany?.update,\r\n                    result,\r\n                  },\r\n                );\r\n              } else if (op.deleteOne || op.deleteMany) {\r\n                interceptor.notifyCallbacks(\r\n                  'delete',\r\n                  collection.collectionName,\r\n                  {\r\n                    filter: op.deleteOne?.filter || op.deleteMany?.filter,\r\n                    result,\r\n                  },\r\n                );\r\n              } else if (op.replaceOne) {\r\n                interceptor.notifyCallbacks(\r\n                  'update',\r\n                  collection.collectionName,\r\n                  {\r\n                    filter: op.replaceOne.filter,\r\n                    replacement: op.replaceOne.replacement,\r\n                    result,\r\n                  },\r\n                );\r\n              }\r\n            });\r\n          } else if (\r\n            ['deleteOne', 'deleteMany', 'findOneAndDelete'].includes(\r\n              prop as string,\r\n            )\r\n          ) {\r\n            interceptor.notifyCallbacks('delete', collection.collectionName, {\r\n              filter: args[0],\r\n              options: args[1],\r\n              result,\r\n            });\r\n          }\r\n          return result;\r\n        };\r\n      },\r\n    };\r\n    return new Proxy(collection, handler);\r\n  }\r\n  private setupCallbacks(): void {\r\n    const interceptor = MongoInterceptor.getInstance();\r\n\r\n    interceptor.addCallback('insert', (collectionName, data) => {\r\n      if (collectionName === this.dataSource) {\r\n        this.notifyDataChange('dataInserted', {\r\n          fullDocument: data.fullDocument,\r\n          fullDocuments: data.fullDocuments,\r\n          source: this.dataSource,\r\n        });\r\n      }\r\n    });\r\n\r\n    interceptor.addCallback('update', (collectionName, data) => {\r\n      if (collectionName === this.dataSource) {\r\n        this.notifyDataChange('dataUpdated', {\r\n          documentKey: { _id: data.filter._id },\r\n          updateDescription: { updatedFields: data.update.$set || {} },\r\n          source: this.dataSource,\r\n        });\r\n      }\r\n    });\r\n\r\n    interceptor.addCallback('delete', (collectionName, data) => {\r\n      if (collectionName === this.dataSource) {\r\n        this.notifyDataChange('dataDeleted', {\r\n          documentKey: { _id: data.filter._id },\r\n          source: this.dataSource,\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  protected makeQuery(conditions: FilterCondition[]): Record<string, any> {\r\n    return conditions.reduce((query, condition) => {\r\n      switch (condition.operator) {\r\n        case FilterOperator.IN:\r\n          return {\r\n            ...query,\r\n            [condition.field]: { $in: condition.value },\r\n          };\r\n        case FilterOperator.EQUALS:\r\n          return {\r\n            ...query,\r\n            [condition.field]: condition.value,\r\n          };\r\n        case FilterOperator.GT:\r\n          return {\r\n            ...query,\r\n            [condition.field]: { $gt: condition.value },\r\n          };\r\n        case FilterOperator.LT:\r\n          return {\r\n            ...query,\r\n            [condition.field]: { $lt: condition.value },\r\n          };\r\n        case FilterOperator.CONTAINS:\r\n          return {\r\n            ...query,\r\n            [condition.field]: {\r\n              $in: Array.isArray(condition.value)\r\n                ? condition.value\r\n                : [condition.value],\r\n            },\r\n          };\r\n        case FilterOperator.REGEX:\r\n          return {\r\n            ...query,\r\n            [condition.field]: {\r\n              $in: Array.isArray(condition.value)\r\n                ? condition.value.map((val) => new RegExp(val, 'i'))\r\n                : [new RegExp(condition.value, 'i')],\r\n            },\r\n          };\r\n        default:\r\n          throw new Error(`Unsupported operator: ${condition.operator}`);\r\n      }\r\n    }, {});\r\n  }\r\n\r\n  async create(data: Document): Promise<WithId<Document>> {\r\n    try {\r\n      const result: InsertOneResult<Document> =\r\n        await this.collection.insertOne(data);\r\n      if (!result.acknowledged) {\r\n        throw new Error('Document insertion was not acknowledged');\r\n      }\r\n      return { ...data, _id: result.insertedId };\r\n    } catch (error) {\r\n      Logger.info(\r\n        `Error during document insertion: ${(error as Error).message}`,\r\n      );\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async delete(id: string): Promise<boolean> {\r\n    try {\r\n      const result = await this.collection.deleteOne({ _id: new ObjectId(id) });\r\n\r\n      if (result.deletedCount === 0) {\r\n        Logger.warn(`No document found with id: ${id}`);\r\n        return false;\r\n      }\r\n\r\n      Logger.info(`Document with id: ${id} successfully deleted`);\r\n      return true;\r\n    } catch (error) {\r\n      Logger.error(\r\n        `Error during document deletion: ${(error as Error).message}`,\r\n      );\r\n      throw error;\r\n    }\r\n  }\r\n  async find(criteria: SearchCriteria): Promise<[]> {\r\n    const query = this.makeQuery(criteria.conditions);\r\n    const data = (await this.collection\r\n      .find(query)\r\n      .limit(criteria.limit || 0)\r\n      .toArray()) as Array<{ _id?: any; [key: string]: any }>;\r\n    return data.map((item) => {\r\n      if (item._id) {\r\n        const { _id, ...rest } = item;\r\n        return {\r\n          _id: _id.toString(),\r\n          ...rest,\r\n        };\r\n      }\r\n      return item;\r\n    }) as [];\r\n  }\r\n\r\n  async update(criteria: SearchCriteria, data: unknown): Promise<boolean> {\r\n    try {\r\n      const updateData = data as MatchKeysAndValues<Document>;\r\n      const query = this.makeQuery(criteria.conditions);\r\n      const result = await this.collection.updateOne(query, {\r\n        $set: updateData,\r\n      });\r\n      if (result.matchedCount === 0) {\r\n        Logger.warn(`No document found matching the criteria`);\r\n        return false;\r\n      }\r\n      if (result.modifiedCount === 0) {\r\n        Logger.info(`No changes made to document`);\r\n        return false;\r\n      }\r\n      Logger.info(`Document successfully updated`);\r\n      return true;\r\n    } catch (error) {\r\n      Logger.error(`Error during document update: ${(error as Error).message}`);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async findOne(criteria: SearchCriteria): Promise<any> {\r\n    const query = this.makeQuery(criteria.conditions);\r\n    const data = (await this.collection\r\n      .findOne(query));\r\n    return data;\r\n  }\r\n\r\n  async findOneAndUpdate(criteria: SearchCriteria, data: any): Promise<any> {\r\n    const query = this.makeQuery(criteria.conditions);\r\n    return (await this.collection\r\n      .findOneAndUpdate(query, { $set: data }, { returnDocument: 'after' }));\r\n  }\r\n\r\n  async findOneAndPush(criteria: SearchCriteria, data: any): Promise<any> {\r\n    const query = this.makeQuery(criteria.conditions);\r\n    Object.keys(data).map((key: string) => {\r\n      data[key].map((element: { _id: ObjectId; }) => element._id = new ObjectId());\r\n      data[key] = { $each: data[key] };\r\n    })\r\n    return (await this.collection\r\n      .findOneAndUpdate(query, { $push: data }, { returnDocument: 'after' }));\r\n  }\r\n\r\n  async findOneAndPull(criteria: SearchCriteria, data: any): Promise<any> {\r\n    const query = this.makeQuery(criteria.conditions);\r\n    return (await this.collection\r\n      .findOneAndUpdate(query, { $pull: data }, { returnDocument: 'after' }));\r\n  }\r\n}\r\n","import { Profile } from './Profile';\r\nimport { Logger } from './Logger';\r\nimport { Contract } from './Contract';\r\n\r\nexport class MatchingService {\r\n  private static instance: MatchingService;\r\n\r\n  static retrieveService(refresh: boolean = false): MatchingService {\r\n    if (!MatchingService.instance || refresh) {\r\n      const instance = new MatchingService();\r\n      MatchingService.instance = instance;\r\n    }\r\n    return MatchingService.instance;\r\n  }\r\n\r\n  async updateProfile(profile: Profile, data: unknown): Promise<void> {\r\n    try {\r\n      const contract: Contract = data as Contract;\r\n\r\n      const otherParticipantsServices = contract.serviceOfferings.filter(\r\n        (service) => service.participant !== profile.uri,\r\n      );\r\n\r\n      if (!otherParticipantsServices.length) return;\r\n\r\n      const currentRecommendation = profile.recommendations[0];\r\n      if (!currentRecommendation) {\r\n        Logger.error('No recommendations available to compare against.');\r\n        return;\r\n      }\r\n\r\n      let matchingEntry = profile.matching[0];\r\n      if (!matchingEntry) {\r\n        matchingEntry = {\r\n          policies: [],\r\n          ecosystemContracts: [],\r\n          services: [],\r\n        };\r\n        profile.matching.push(matchingEntry);\r\n      }\r\n\r\n      otherParticipantsServices.forEach((service) => {\r\n        service.policies?.forEach((policy) => {\r\n          const matchingPolicy = currentRecommendation?.policies?.find(\r\n            (recPolicy) => recPolicy.policy === policy.description,\r\n          );\r\n\r\n          if (matchingPolicy) {\r\n            const existingMatchingPolicy = matchingEntry.policies.find(\r\n              (mp) => mp.policy === policy.description,\r\n            );\r\n            if (existingMatchingPolicy) {\r\n              existingMatchingPolicy.frequency += 1;\r\n            } else {\r\n              matchingEntry.policies.push({\r\n                policy: policy.description,\r\n                frequency: 1,\r\n              });\r\n            }\r\n          }\r\n        });\r\n\r\n        const matchingService = currentRecommendation?.services?.find(\r\n          (recService) =>\r\n            recService.serviceOffering === service.serviceOffering,\r\n        );\r\n\r\n        if (matchingService) {\r\n          const existingMatchingService = matchingEntry.services.find(\r\n            (ms) => ms.serviceOffering === service.serviceOffering,\r\n          );\r\n          if (existingMatchingService) {\r\n            existingMatchingService.frequency += 1;\r\n          } else {\r\n            matchingEntry.services.push({\r\n              serviceOffering: service.serviceOffering,\r\n              frequency: 1,\r\n            });\r\n          }\r\n        }\r\n      });\r\n\r\n      if (!matchingEntry.ecosystemContracts.includes(contract._id)) {\r\n        matchingEntry.ecosystemContracts.push(contract._id);\r\n      }\r\n\r\n      profile.matching[0] = matchingEntry;\r\n    } catch (error) {\r\n      Logger.error(\r\n        `Profile matching update failed: ${(error as Error).message}`,\r\n      );\r\n    }\r\n  }\r\n}\r\n","import { Profile } from './Profile';\r\nimport { Logger } from './Logger';\r\nimport { Contract } from './Contract';\r\n\r\nexport class RecommendationService {\r\n  private static instance: RecommendationService;\r\n\r\n  static retrieveService(refresh: boolean = false): RecommendationService {\r\n    if (!RecommendationService.instance || refresh) {\r\n      const instance = new RecommendationService();\r\n      RecommendationService.instance = instance;\r\n    }\r\n    return RecommendationService.instance;\r\n  }\r\n\r\n  async updateProfile(profile: Profile, data: unknown): Promise<void> {\r\n    try {\r\n      const contract: Contract = data as Contract;\r\n\r\n      const newPolicyDescriptions =\r\n        this.collectPolicyDescriptionsForParticipant(contract, profile.uri ?? '');\r\n      const newServiceOfferings = this.collectServiceOfferingsForParticipant(\r\n        contract,\r\n        profile.uri ?? '',\r\n      );\r\n      const contractId = contract._id;\r\n\r\n      let recommendation = profile.recommendations[0];\r\n\r\n      if (!recommendation) {\r\n        recommendation = {\r\n          policies: [],\r\n          ecosystemContracts: [],\r\n          services: [],\r\n        };\r\n        profile.recommendations.push(recommendation);\r\n      }\r\n\r\n      newPolicyDescriptions.forEach((newPolicyDescription) => {\r\n        const existingPolicy = recommendation.policies?.find(\r\n          (p) => p.policy === newPolicyDescription,\r\n        );\r\n\r\n        if (existingPolicy) {\r\n          existingPolicy.frequency += 1;\r\n        } else {\r\n          recommendation.policies = recommendation.policies || [];\r\n          recommendation.policies.push({\r\n            policy: newPolicyDescription,\r\n            frequency: 1,\r\n          });\r\n        }\r\n      });\r\n\r\n      if (\r\n        contractId &&\r\n        !recommendation?.ecosystemContracts?.includes(contractId)\r\n      ) {\r\n        recommendation?.ecosystemContracts?.push(contractId);\r\n      }\r\n\r\n      newServiceOfferings.forEach((newServiceOffering) => {\r\n        const existingService = recommendation.services?.find(\r\n          (s) => s.serviceOffering === newServiceOffering,\r\n        );\r\n\r\n        if (existingService) {\r\n          existingService.frequency += 1;\r\n        } else {\r\n          recommendation.services = recommendation.services || [];\r\n          recommendation.services.push({\r\n            serviceOffering: newServiceOffering,\r\n            frequency: 1,\r\n          });\r\n        }\r\n      });\r\n\r\n      profile.recommendations[0] = recommendation;\r\n    } catch (error) {\r\n      Logger.error(\r\n        `Profile recommendation update failed: ${(error as Error).message}`,\r\n      );\r\n    }\r\n  }\r\n\r\n  private collectPolicyDescriptionsForParticipant(\r\n    contract: Contract,\r\n    participantUri: string,\r\n  ): string[] {\r\n    const descriptions = new Set<string>();\r\n\r\n    contract.serviceOfferings?.forEach((service) => {\r\n      if (service.participant === participantUri) {\r\n        service.policies?.forEach((policy) => {\r\n          if (policy?.description) {\r\n            descriptions.add(policy.description);\r\n          }\r\n        });\r\n      }\r\n    });\r\n\r\n    return Array.from(descriptions);\r\n  }\r\n\r\n  private collectServiceOfferingsForParticipant(\r\n    contract: Contract,\r\n    participantUri: string,\r\n  ): string[] {\r\n    const services = new Set<string>();\r\n\r\n    contract.serviceOfferings?.forEach((service) => {\r\n      if (service.participant === participantUri && service.serviceOffering) {\r\n        services.add(service.serviceOffering);\r\n      }\r\n    });\r\n\r\n    return Array.from(services);\r\n  }\r\n}\r\n","import { Profile, ProfileJSON } from './Profile';\r\nimport {\r\n  FilterCondition,\r\n  FilterOperator,\r\n  ProfileDocument,\r\n  SearchCriteria,\r\n  ContractAgentError,\r\n  DataChangeEvent,\r\n  CAECode,\r\n} from './types';\r\nimport { Agent } from './Agent';\r\nimport { Contract } from './Contract';\r\nimport { Logger } from './Logger';\r\nimport { DataProvider, DataProviderType } from './DataProvider';\r\nimport { MongoDBProvider } from './MongoDBProvider';\r\nimport { MatchingService } from './MatchingService';\r\nimport { RecommendationService } from './RecommendationService';\r\nimport { randomUUID } from 'crypto';\r\nimport { setTimeout } from 'timers';\r\n\r\ninterface WaitFunction {\r\n  (_ms: number): Promise<void>;\r\n}\r\n\r\nexport const wait: WaitFunction = (ms: number) =>\r\n  new Promise<void>((resolve) => setTimeout(resolve, ms));\r\n\r\n/**\r\n * ContractAgent class handles contract-related operations and profile management\r\n * @extends Agent\r\n */\r\nexport class ContractAgent extends Agent {\r\n  private static instance: ContractAgent | null = null;\r\n  public _uid: string;\r\n\r\n  private constructor() {\r\n    super();\r\n    this._uid = randomUUID();\r\n  }\r\n\r\n  /**\r\n   * Prepares the ContractAgent instance by loading configuration and setting up providers\r\n   * @throws {ContractAgentError} If preparation fails\r\n   */\r\n  async prepare(): Promise<void> {\r\n    try {\r\n      this.loadDefaultConfiguration();\r\n      await this.addDefaultProviders();\r\n      this.setupProviderEventHandlers();\r\n    } catch (error) {\r\n      const agentError: ContractAgentError = {\r\n        name: 'PreparationError',\r\n        message: `Failed to prepare ContractAgent: ${(error as Error).message}`,\r\n        code: CAECode.PREPARATION_FAILED,\r\n      };\r\n      Logger.error(agentError.message);\r\n      throw agentError;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieves or creates a ContractAgent instance\r\n   * @param dataProviderType - Type of data provider to use\r\n   * @param refresh - Whether to force create a new instance\r\n   * @returns Promise<ContractAgent>\r\n   */\r\n  static async retrieveService(\r\n    dataProviderType: DataProviderType = MongoDBProvider,\r\n    refresh: boolean = false,\r\n  ): Promise<ContractAgent> {\r\n    try {\r\n      if (!ContractAgent.instance || refresh) {\r\n        DataProvider.setChildType(dataProviderType);\r\n        const instance = new ContractAgent();\r\n        await instance.prepare();\r\n        ContractAgent.instance = instance;\r\n      }\r\n      const dpChildType = DataProvider.getChildType();\r\n      if (!dpChildType) {\r\n        Logger.warn('Data Provider Type not set');\r\n      }\r\n      return ContractAgent.instance;\r\n    } catch (error) {\r\n      const serviceError: ContractAgentError = {\r\n        name: 'ServiceRetrievalError',\r\n        message: `Failed to retrieve ContractAgent service: ${(error as Error).message}`,\r\n        code: CAECode.SERVICE_RETRIEVAL_FAILED,\r\n      };\r\n      Logger.error(serviceError.message);\r\n      throw serviceError;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enriches a profile with system recommendations\r\n   * @throws {ContractAgentError} Method not implemented\r\n   */\r\n  protected enrichProfileWithSystemRecommendations(): Profile {\r\n    throw new Error('Method not implemented.');\r\n  }\r\n\r\n  /**\r\n   * Enriches a profile with system recommendations\r\n   * @throws {ContractAgentError} Method not implemented\r\n   */\r\n  protected existingDataCheck(): Promise<void> {\r\n    throw new Error('Method not implemented.');\r\n  }\r\n\r\n  /**\r\n   * Finds profiles across all configured providers\r\n   * @param criteria - Search criteria\r\n   * @returns Promise<Profile[]>\r\n   */\r\n  async findProfilesAcrossProviders(\r\n    criteria: SearchCriteria,\r\n  ): Promise<Profile[]> {\r\n    const allProfiles: Profile[] = [];\r\n\r\n    if (!this.config) {\r\n      throw new Error('Configuration is not initialized');\r\n    }\r\n\r\n    Logger.info(\r\n      `Searching across data sources: ${this.config.dataProviderConfig\r\n        .map((config) => config.source)\r\n        .join(', ')}`,\r\n    );\r\n\r\n    for (const dataProvider of this.dataProviders) {\r\n      const { source } = dataProvider;\r\n      if (!source) {\r\n        throw new Error('Provider source is undefined');\r\n      }\r\n\r\n      const profiles = await this.findProfiles(source, criteria);\r\n      allProfiles.push(...profiles);\r\n    }\r\n\r\n    return allProfiles;\r\n  }\r\n\r\n  /**\r\n   * Updates profiles based on contract changes\r\n   * @param contract - Contract instance\r\n   * @returns Promise<void>\r\n   */\r\n  private async updateProfileFromContractChange(\r\n    contract: Contract,\r\n  ): Promise<void> {\r\n    if (!contract) {\r\n      throw new Error('Contract is undefined');\r\n    }\r\n    Logger.info('updating profiles for members...');\r\n    await this.updateProfilesForMembers(contract);\r\n    Logger.info('updating profiles for offerings...');\r\n    await this.updateProfilesForServiceOfferings(contract);\r\n    Logger.info('updating profiles for orchestrator...');\r\n    await this.updateProfileForOrchestrator(contract);\r\n    this.signalUpdate();\r\n  }\r\n\r\n  signalUpdate(): void {}\r\n\r\n  /**\r\n   * Updates profiles for all contract members\r\n   * @param contract - Contract instance\r\n   */\r\n  private async updateProfilesForMembers(contract: Contract): Promise<void> {\r\n    for (const member of contract.members) {\r\n      if (member?.participant?.length) {\r\n        await this.updateProfile(member.participant, contract);\r\n      }\r\n    }\r\n    if (!contract?.members?.length) {\r\n      Logger.warn('no members found, 0 profile updated');\r\n    } else {\r\n      Logger.info(`${contract.members.length} profiles found for members`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates profiles for all service offerings\r\n   * @param contract - Contract instance\r\n   */\r\n  private async updateProfilesForServiceOfferings(\r\n    contract: Contract,\r\n  ): Promise<void> {\r\n    const uniqueParticipants = new Set<string>();\r\n    for (const offering of contract.serviceOfferings || []) {\r\n      if (offering?.participant?.length) {\r\n        uniqueParticipants.add(offering.participant);\r\n        await this.updateProfile(offering.participant, contract);\r\n      }\r\n    }\r\n    const offeringsCount = contract.serviceOfferings?.length || 0;\r\n    if (!offeringsCount) {\r\n      Logger.warn('no service offerings found, 0 profile updated');\r\n    } else {\r\n      Logger.info(\r\n        `${offeringsCount} service offerings with ${uniqueParticipants.size} unique participants processed`,\r\n      );\r\n    }\r\n  }\r\n  /**\r\n   * Updates profile for contract orchestrator\r\n   * @param contract - Contract instance\r\n   */\r\n  private async updateProfileForOrchestrator(\r\n    contract: Contract,\r\n  ): Promise<void> {\r\n    if (contract?.orchestrator?.length) {\r\n      await this.updateProfile(contract.orchestrator, contract);\r\n      Logger.info('Profile updated for orchestrator');\r\n    } else {\r\n      Logger.warn('no orchestrator found, 0 profile updated');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates a single profile\r\n   * @param participantId - Participant identifier\r\n   * @param contract - Contract instance\r\n   */\r\n  private async updateProfile(\r\n    participantId: string,\r\n    contract: Contract,\r\n  ): Promise<void> {\r\n    try {\r\n      const profileProvider = this.dataProviders.find(\r\n        (dataProvider) => dataProvider.source === 'profiles',\r\n      );\r\n\r\n      if (!profileProvider) {\r\n        throw new Error('Profile DataProvider not found');\r\n      }\r\n\r\n      const conditions: FilterCondition = {\r\n        field: 'uri',\r\n        operator: FilterOperator.EQUALS,\r\n        value: participantId,\r\n      };\r\n      const criteria: SearchCriteria = {\r\n        conditions: [conditions],\r\n        threshold: 0,\r\n      };\r\n\r\n      const source = profileProvider.source;\r\n      if (!source) {\r\n        throw new Error('Provider \"source\" is undefined');\r\n      }\r\n\r\n      const profiles = await this.findProfiles(source, criteria);\r\n      const profile =\r\n        profiles[0] ?? (await this.createProfileForParticipant(participantId));\r\n\r\n      await this.updateRecommendationForProfile(profile, contract);\r\n      await this.updateMatchingForProfile(profile, contract);\r\n    } catch (error) {\r\n      Logger.error(`Update profile failed: ${(error as Error).message}`);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handles inserted data events\r\n   * @param data - Data change event\r\n   */\r\n  protected async handleDataInserted(data: DataChangeEvent): Promise<void> {\r\n    if (data.source === 'contracts' && data.fullDocument) {\r\n      try {\r\n        await this.updateProfileFromContractChange(\r\n          data.fullDocument as Contract,\r\n        );\r\n        Logger.info(`Data inserted for source: ${data.source}`);\r\n      } catch (error) {\r\n        Logger.error(`Data insertion failed: ${(error as Error).message}`);\r\n        throw error;\r\n      }\r\n    } else {\r\n      Logger.info(`Unhandled data insertion for source: ${data.source}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handles updated data events\r\n   * @param data - Data change event\r\n   */\r\n  protected async handleDataUpdated(data: DataChangeEvent): Promise<void> {\r\n    if (data.source === 'contracts' && data.updateDescription?.updatedFields) {\r\n      await this.updateProfileFromContractChange(\r\n        data.updateDescription.updatedFields as Contract,\r\n      );\r\n    } else {\r\n      Logger.info(`Unhandled data update for source: ${data.source}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handles deleted data events\r\n   * @param data - Data change event\r\n   */\r\n  protected handleDataDeleted(data: DataChangeEvent): void {\r\n    if (data.source === 'contracts') {\r\n      Logger.info(`Removing contract: ${data.documentKey?._id}`);\r\n    } else {\r\n      Logger.info(`Unhandled data deletion for source: ${data.source}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates matching information for a profile\r\n   * @param profile - Profile instance\r\n   * @param data - Matching data\r\n   */\r\n  protected async updateMatchingForProfile(\r\n    profile: Profile,\r\n    data: unknown,\r\n  ): Promise<void> {\r\n    const matchingService = MatchingService.retrieveService();\r\n    await matchingService.updateProfile(profile, data);\r\n  }\r\n\r\n  /**\r\n   * Updates recommendations for a profile\r\n   * @param profile - Profile instance\r\n   * @param data - Recommendation data\r\n   */\r\n  protected async updateRecommendationForProfile(\r\n    profile: Profile,\r\n    data: unknown,\r\n  ): Promise<void> {\r\n    try {\r\n      const recommendationService = RecommendationService.retrieveService();\r\n      await recommendationService.updateProfile(profile, data);\r\n      const criteria: SearchCriteria = {\r\n        conditions: [\r\n          {\r\n            field: 'uri',\r\n            operator: FilterOperator.EQUALS,\r\n            value: profile.uri,\r\n          },\r\n        ],\r\n        threshold: 0,\r\n      };\r\n      const saved = await this.saveProfile('profiles', criteria, profile);\r\n\r\n      if (!saved) {\r\n        throw new Error(`Failed to save updated profile: ${profile.uri}`);\r\n      }\r\n      Logger.info(\r\n        `Recommendations updated and profile saved for: ${profile.uri}`,\r\n      );\r\n    } catch (error) {\r\n      Logger.error(\r\n        `Error updating recommendations for profile: ${(error as Error).message}`,\r\n      );\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Finds profiles based on given criteria from a specific source\r\n   * @param source - Data source identifier\r\n   * @param criteria - Search criteria\r\n   * @returns Promise<Profile[]>\r\n   */\r\n  async findProfiles(\r\n    source: string,\r\n    criteria: SearchCriteria,\r\n  ): Promise<Profile[]> {\r\n    try {\r\n      const dataProvider = this.getDataProvider(source);\r\n      if (!dataProvider) {\r\n        throw new Error(`Data provider not found for source: ${source}`);\r\n      }\r\n      const results: ProfileDocument[] = await dataProvider.find(criteria);\r\n      return results.map((result) => {\r\n        const profileData: ProfileJSON = {\r\n          _id: result._id,\r\n          uri: result.uri,\r\n          configurations: result.configurations,\r\n          recommendations: result.recommendations || [],\r\n          matching: result.matching || [],\r\n          preference: result.preference || [],\r\n        };\r\n        return new Profile(profileData);\r\n      });\r\n    } catch (error) {\r\n      const searchError: ContractAgentError = {\r\n        name: 'ProfileSearchError',\r\n        message: `Failed to find profiles: ${(error as Error).message}`,\r\n        code: CAECode.PROFILE_SEARCH_FAILED,\r\n        context: { source, criteria },\r\n      };\r\n      Logger.error(searchError.message);\r\n      throw searchError;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Saves a profile to a specified data source\r\n   * @param source - Data source identifier\r\n   * @param criteria - Search criteria used to find the profile to update\r\n   * @param profile - Profile to be saved\r\n   * @returns Promise<boolean> - Indicates successful save operation\r\n   */\r\n  async saveProfile(\r\n    source: string,\r\n    criteria: SearchCriteria,\r\n    profile: Profile,\r\n  ): Promise<boolean> {\r\n    try {\r\n      const dataProvider = this.getDataProvider(source);\r\n      if (!dataProvider) {\r\n        throw new Error(`Data provider not found for source: ${source}`);\r\n      }\r\n      const profileDocument: ProfileDocument = {\r\n        uri: profile.uri,\r\n        configurations: profile.configurations,\r\n        recommendations: profile.recommendations || [],\r\n        matching: profile.matching || [],\r\n        preference: profile.preference || [],\r\n      };\r\n      const updateResult = await dataProvider.update(criteria, profileDocument);\r\n      if (!updateResult) {\r\n        Logger.warn(\r\n          `No profile found matching criteria to update for source: ${source}`,\r\n        );\r\n        return false;\r\n      }\r\n      Logger.info(`Profile saved successfully to source: ${source}`);\r\n      return true;\r\n    } catch (error) {\r\n      const saveError: ContractAgentError = {\r\n        name: 'ProfileSaveError',\r\n        message: `Failed to save profile: ${(error as Error).message}`,\r\n        code: CAECode.PROFILE_SAVE_FAILED,\r\n        context: { source, profile },\r\n      };\r\n      Logger.error(saveError.message);\r\n      throw saveError;\r\n    }\r\n  }\r\n\r\n  async createProfileForParticipant(participantURI: string): Promise<Profile> {\r\n    try {\r\n      if (!Agent.profilesHost) {\r\n        throw new Error(\r\n          `Can't create profile for participant \"profilesHost\" is not set`,\r\n        );\r\n      }\r\n      const criteria: SearchCriteria = {\r\n        conditions: [\r\n          {\r\n            field: 'uri',\r\n            operator: FilterOperator.EQUALS,\r\n            value: participantURI,\r\n          },\r\n        ],\r\n        threshold: 0,\r\n      };\r\n      const existingProfile = await this.findProfiles('profiles', criteria);\r\n\r\n      if (existingProfile?.length && existingProfile[0]) {\r\n        Logger.warn(\r\n          `Profile already exists for participant: ${participantURI}`,\r\n        );\r\n        return existingProfile[0];\r\n      }\r\n\r\n      const profileProvider = this.getDataProvider(Agent.profilesHost);\r\n      const newProfileData = {\r\n        uri: participantURI,\r\n        configurations: {},\r\n        recommendations: [],\r\n        matching: [],\r\n      };\r\n\r\n      const profile = await profileProvider.create(newProfileData);\r\n      const newProfile = new Profile(profile as ProfileJSON);\r\n      const saved = await this.saveProfile('profiles', criteria, newProfile);\r\n\r\n      if (!saved) {\r\n        throw new Error(`Failed to save new profile for: ${participantURI}`);\r\n      }\r\n      Logger.info(`New profile created and saved for: ${participantURI}`);\r\n      return newProfile;\r\n    } catch (error) {\r\n      Logger.error(`Error creating profile: ${(error as Error).message}`);\r\n      throw new Error('Profile creation failed');\r\n    }\r\n  }\r\n}\r\n","import { Profile } from './Profile';\r\nimport { Agent } from './Agent';\r\nimport { ContractAgent } from './ContractAgent';\r\nimport { SearchCriteria, FilterOperator } from './types';\r\nimport { Logger } from './Logger';\r\n\r\nexport class RequestHandler {\r\n  private static instance: RequestHandler | null = null;\r\n  private contractAgent?: ContractAgent;\r\n  private profilesHost: string = '';\r\n  private constructor() {}\r\n\r\n  static async retrieveService(): Promise<RequestHandler> {\r\n    if (!RequestHandler.instance) {\r\n      const instance = new RequestHandler();\r\n      await instance.prepare();\r\n      RequestHandler.instance = instance;\r\n    }\r\n    return RequestHandler.instance;\r\n  }\r\n\r\n  private async prepare() {\r\n    this.contractAgent = await ContractAgent.retrieveService();\r\n    this.profilesHost = Agent.getProfileHost();\r\n    if (!this.profilesHost) {\r\n      throw new Error('Contract Request Handler: Profiles Host not set');\r\n    }\r\n  }\r\n\r\n  async getContractAgent(): Promise<ContractAgent> {\r\n    return ContractAgent.retrieveService();\r\n  }\r\n\r\n  // Return only the policies from recommendations\r\n  async getPoliciesRecommendationFromProfile(profileURI: string): Promise<any> {\r\n    try {\r\n      const criteria: SearchCriteria = {\r\n        conditions: [\r\n          {\r\n            field: 'uri',\r\n            operator: FilterOperator.EQUALS,\r\n            value: profileURI,\r\n          },\r\n        ],\r\n        threshold: 0,\r\n      };\r\n      if (!this.contractAgent) {\r\n        throw new Error('Contract Agent undefined');\r\n      }\r\n      const profiles = await this.contractAgent.findProfiles(\r\n        this.profilesHost,\r\n        criteria,\r\n      );\r\n      if (profiles.length === 0) {\r\n        throw new Error(`Profile not found, profileURI: ${profileURI}`);\r\n      }\r\n      return profiles[0].recommendations.map((rec) => rec.policies);\r\n    } catch (error) {\r\n      Logger.error((error as Error).message);\r\n    }\r\n  }\r\n\r\n  // Return only the services from recommendations\r\n  async getServicesRecommendationFromProfile(profileId: string): Promise<any> {\r\n    const criteria: SearchCriteria = {\r\n      conditions: [\r\n        {\r\n          field: 'uri',\r\n          operator: FilterOperator.EQUALS,\r\n          value: profileId,\r\n        },\r\n      ],\r\n      threshold: 0,\r\n    };\r\n    if (!this.contractAgent) {\r\n      throw new Error('Contract Agent undefined');\r\n    }\r\n    const profiles = await this.contractAgent.findProfiles(\r\n      this.profilesHost,\r\n      criteria,\r\n    );\r\n    if (profiles.length === 0) {\r\n      throw new Error('Profile not found');\r\n    }\r\n    return profiles[0].recommendations.map((rec) => rec.services);\r\n  }\r\n\r\n  // Return only the policies from matching\r\n  async getPoliciesMatchingFromProfile(profileId: string): Promise<any> {\r\n    const criteria: SearchCriteria = {\r\n      conditions: [\r\n        {\r\n          field: 'uri',\r\n          operator: FilterOperator.EQUALS,\r\n          value: profileId,\r\n        },\r\n      ],\r\n      threshold: 0,\r\n    };\r\n\r\n    if (!this.contractAgent) {\r\n      throw new Error('Contract Agent undefined');\r\n    }\r\n    const profiles = await this.contractAgent.findProfiles(\r\n      this.profilesHost,\r\n      criteria,\r\n    );\r\n    if (profiles.length === 0) {\r\n      throw new Error('Profile not found');\r\n    }\r\n    return profiles[0].matching.map((match) => match.policies);\r\n  }\r\n\r\n  // Return only the services from matching\r\n  async getServicesMatchingFromProfile(profileId: string): Promise<any> {\r\n    const criteria: SearchCriteria = {\r\n      conditions: [\r\n        {\r\n          field: 'uri',\r\n          operator: FilterOperator.EQUALS,\r\n          value: profileId,\r\n        },\r\n      ],\r\n      threshold: 0,\r\n    };\r\n    if (!this.contractAgent) {\r\n      throw new Error('Contract Agent undefined');\r\n    }\r\n    const profiles = await this.contractAgent.findProfiles(\r\n      this.profilesHost,\r\n      criteria,\r\n    );\r\n    if (profiles.length === 0) {\r\n      throw new Error('Profile not found');\r\n    }\r\n    return profiles[0].matching.map((match) => match.services);\r\n  }\r\n\r\n  // Return only the ecosystemContracts from matching\r\n  async getContractMatchingFromProfile(profileId: string): Promise<any> {\r\n    const criteria: SearchCriteria = {\r\n      conditions: [\r\n        {\r\n          field: 'uri',\r\n          operator: FilterOperator.EQUALS,\r\n          value: profileId,\r\n        },\r\n      ],\r\n      threshold: 0,\r\n    };\r\n\r\n    if (!this.contractAgent) {\r\n      throw new Error('Contract Agent undefined');\r\n    }\r\n    const profiles = await this.contractAgent.findProfiles(\r\n      this.profilesHost,\r\n      criteria,\r\n    );\r\n    if (profiles.length === 0) {\r\n      throw new Error('Profile not found');\r\n    }\r\n    return profiles[0].matching.map((match) => match.ecosystemContracts);\r\n  }\r\n\r\n  // configurations\r\n\r\n  async getConfigurationsFromProfile(profileURI: string): Promise<any> {\r\n    const criteria: SearchCriteria = {\r\n      conditions: [\r\n        {\r\n          field: 'uri',\r\n          operator: FilterOperator.EQUALS,\r\n          value: profileURI,\r\n        },\r\n      ],\r\n      threshold: 0,\r\n    };\r\n    if (!this.contractAgent) {\r\n      throw new Error('Contract Agent undefined');\r\n    }\r\n    const profiles = await this.contractAgent.findProfiles(\r\n      this.profilesHost,\r\n      criteria,\r\n    );\r\n    if (profiles.length === 0) {\r\n      throw new Error('Profile not found');\r\n    }\r\n    return profiles[0].configurations;\r\n  }\r\n\r\n  async addConfigurationsToProfile(\r\n    profileURI: string,\r\n    configurations: any,\r\n  ): Promise<any> {\r\n    const criteria: SearchCriteria = {\r\n      conditions: [\r\n        {\r\n          field: 'uri',\r\n          operator: FilterOperator.EQUALS,\r\n          value: profileURI,\r\n        },\r\n      ],\r\n      threshold: 0,\r\n    };\r\n    if (!this.contractAgent) {\r\n      throw new Error('Contract Agent undefined');\r\n    }\r\n    const profiles = await this.contractAgent.findProfiles(\r\n      this.profilesHost,\r\n      criteria,\r\n    );\r\n    if (profiles.length === 0) {\r\n      throw new Error('Profile not found');\r\n    }\r\n    const profile = profiles[0];\r\n    profile.configurations = { ...profile.configurations, ...configurations };\r\n    await this.contractAgent.saveProfile(this.profilesHost, criteria, profile);\r\n    return { message: 'Configurations added successfully', profile };\r\n  }\r\n\r\n  async updateConfigurationsForProfile(\r\n    profileId: string,\r\n    configurations: any,\r\n  ): Promise<any> {\r\n    const criteria: SearchCriteria = {\r\n      conditions: [\r\n        {\r\n          field: 'uri',\r\n          operator: FilterOperator.EQUALS,\r\n          value: profileId,\r\n        },\r\n      ],\r\n      threshold: 0,\r\n    };\r\n    if (!this.contractAgent) {\r\n      throw new Error('Contract Agent undefined');\r\n    }\r\n    const profiles = await this.contractAgent.findProfiles(\r\n      this.profilesHost,\r\n      criteria,\r\n    );\r\n    if (profiles.length === 0) {\r\n      throw new Error('Profile not found');\r\n    }\r\n    const profile = profiles[0];\r\n    profile.configurations = configurations;\r\n    await this.contractAgent.saveProfile(this.profilesHost, criteria, profile);\r\n    return { message: 'Configurations updated successfully', profile };\r\n  }\r\n\r\n  async removeConfigurationsFromProfile(profileId: string): Promise<any> {\r\n    const criteria: SearchCriteria = {\r\n      conditions: [\r\n        {\r\n          field: 'uri',\r\n          operator: FilterOperator.EQUALS,\r\n          value: profileId,\r\n        },\r\n      ],\r\n      threshold: 0,\r\n    };\r\n    if (!this.contractAgent) {\r\n      throw new Error('Contract Agent undefined');\r\n    }\r\n    const profiles = await this.contractAgent.findProfiles(\r\n      this.profilesHost,\r\n      criteria,\r\n    );\r\n    if (profiles.length === 0) {\r\n      throw new Error('Profile not found');\r\n    }\r\n    const profile: Profile = profiles[0];\r\n    profile.configurations = {\r\n      allowRecommendations: false,\r\n      allowPolicies: false,\r\n    };\r\n    await this.contractAgent.saveProfile(this.profilesHost, criteria, profile);\r\n    return { message: 'Configurations removed successfully', profile };\r\n  }\r\n}\r\n","import { RequestHandler } from './ContractAgentHandler';\r\nimport { Request, Response, Router } from 'express';\r\nconst router: Router = Router();\r\n\r\n/**\r\n * Handles the request to get policies recommendations for a profile.\r\n * \r\n * @param {Request} req - The incoming request object.\r\n * @param {Response} res - The response object to send back to the client.\r\n */\r\nrouter.get(\r\n  '/profile/:id/policies-recommendations',\r\n  async (req: Request, res: Response) => {\r\n    // #swagger.tags = ['Contract']\r\n    const requestHandler = await RequestHandler.retrieveService();\r\n    try {\r\n      const policies =\r\n        await requestHandler.getPoliciesRecommendationFromProfile(\r\n          req.params.id,\r\n        );\r\n      res.json(policies);\r\n    } catch (error) {\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  },\r\n);\r\n\r\n/**\r\n * Handles the request to get services recommendations for a profile.\r\n * \r\n * @param {Request} req - The incoming request object.\r\n * @param {Response} res - The response object to send back to the client.\r\n */\r\nrouter.get(\r\n  '/profile/:id/services-recommendations',\r\n  async (req: Request, res: Response) => {\r\n    // #swagger.tags = ['Contract']\r\n    const requestHandler = await RequestHandler.retrieveService();\r\n    try {\r\n      const services =\r\n        await requestHandler.getServicesRecommendationFromProfile(\r\n          req.params.id,\r\n        );\r\n      res.json(services);\r\n    } catch (error) {\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  },\r\n);\r\n\r\n/**\r\n * Handles the request to get policies matching for a profile.\r\n * \r\n * @param {Request} req - The incoming request object.\r\n * @param {Response} res - The response object to send back to the client.\r\n */\r\nrouter.get(\r\n  '/profile/:id/policies-matching',\r\n  async (req: Request, res: Response) => {\r\n    // #swagger.tags = ['Contract']\r\n    const requestHandler = await RequestHandler.retrieveService();\r\n    try {\r\n      const policies = await requestHandler.getPoliciesMatchingFromProfile(\r\n        req.params.id,\r\n      );\r\n      res.json(policies);\r\n    } catch (error) {\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  },\r\n);\r\n\r\n/**\r\n * Handles the request to get services matching for a profile.\r\n * \r\n * @param {Request} req - The incoming request object.\r\n * @param {Response} res - The response object to send back to the client.\r\n */\r\nrouter.get(\r\n  '/profile/:id/services-matching',\r\n  async (req: Request, res: Response) => {\r\n    // #swagger.tags = ['Contract']\r\n    const requestHandler = await RequestHandler.retrieveService();\r\n    try {\r\n      const services = await requestHandler.getServicesMatchingFromProfile(\r\n        req.params.id,\r\n      );\r\n      res.json(services);\r\n    } catch (error) {\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  },\r\n);\r\n\r\n/**\r\n * Handles the request to get service recommendations for a profile.\r\n * \r\n * @param {Request} req - The incoming request object.\r\n * @param {Response} res - The response object to send back to the client.\r\n */\r\nrouter.get(\r\n  '/profile/:id/service-recommendations',\r\n  async (req: Request, res: Response) => {\r\n    // #swagger.tags = ['Contract']\r\n    const requestHandler = await RequestHandler.retrieveService();\r\n    try {\r\n      const services =\r\n        await requestHandler.getServicesRecommendationFromProfile(\r\n          req.params.id,\r\n        );\r\n      res.json(services);\r\n    } catch (error) {\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  },\r\n);\r\n\r\n/**\r\n * Handles the request to get policies matching for a profile.\r\n * \r\n * @param {Request} req - The incoming request object.\r\n * @param {Response} res - The response object to send back to the client.\r\n */\r\nrouter.get(\r\n  '/profile/:id/policies-matching',\r\n  async (req: Request, res: Response) => {\r\n    // #swagger.tags = ['Contract']\r\n    const requestHandler = await RequestHandler.retrieveService();\r\n    try {\r\n      const policies = await requestHandler.getPoliciesMatchingFromProfile(\r\n        req.params.id,\r\n      );\r\n      res.json(policies);\r\n    } catch (error) {\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  },\r\n);\r\n\r\n/**\r\n * Handles the request to get contract matching for a profile.\r\n * \r\n * @param {Request} req - The incoming request object.\r\n * @param {Response} res - The response object to send back to the client.\r\n */\r\nrouter.get(\r\n  '/profile/:id/contract-matching',\r\n  async (req: Request, res: Response) => {\r\n    // #swagger.tags = ['Contract']\r\n    const requestHandler = await RequestHandler.retrieveService();\r\n    try {\r\n      const contracts = await requestHandler.getContractMatchingFromProfile(\r\n        req.params.id,\r\n      );\r\n      res.json(contracts);\r\n    } catch (error) {\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  },\r\n);\r\n\r\n/**\r\n * Handles the request to get configurations for a profile.\r\n * \r\n * @param {Request} req - The incoming request object.\r\n * @param {Response} res - The response object to send back to the client.\r\n */\r\nrouter.get(\r\n  '/profile/:id/configurations',\r\n  async (req: Request, res: Response) => {\r\n    // #swagger.tags = ['Contract']\r\n    const requestHandler = await RequestHandler.retrieveService();\r\n    try {\r\n      const configurations = await requestHandler.getConfigurationsFromProfile(\r\n        req.params.id,\r\n      );\r\n      res.json(configurations);\r\n    } catch (error) {\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  },\r\n);\r\n\r\n/**\r\n * Handles the request to add configurations to a profile.\r\n * \r\n * @param {Request} req - The incoming request object.\r\n * @param {Response} res - The response object to send back to the client.\r\n */\r\nrouter.post('/profile/configurations', async (req: Request, res: Response) => {\r\n  /*    #swagger.tags = ['Contract']\r\n          #swagger.requestBody = {\r\n            required: true,\r\n            content: {\r\n                \"application/json\": {\r\n                    schema: {\r\n                        $ref: \"#/components/schemas/ContractProfilePostPayload\"\r\n                    }  \r\n                }\r\n            }\r\n        } \r\n    */\r\n  const requestHandler = await RequestHandler.retrieveService();\r\n  try {\r\n    const { profileURI, configurations } = req.body;\r\n    const result = await requestHandler.addConfigurationsToProfile(\r\n      profileURI,\r\n      configurations,\r\n    );\r\n    res.status(201).json({ success: true, ...result });\r\n  } catch (error) {\r\n    res.status(500).json({ error: (error as Error).message });\r\n  }\r\n});\r\n\r\n/**\r\n * Handles the request to update configurations for a profile.\r\n * \r\n * @param {Request} req - The incoming request object.\r\n * @param {Response} res - The response object to send back to the client.\r\n */\r\nrouter.put(\r\n  '/profile/:id/configurations',\r\n  async (req: Request, res: Response) => {\r\n    /*    #swagger.tags = ['Contract']\r\n          #swagger.requestBody = {\r\n            required: true,\r\n            content: {\r\n                \"application/json\": {\r\n                    schema: {\r\n                        $ref: \"#/components/schemas/ContractProfilePutPayload\"\r\n                    }  \r\n                }\r\n            }\r\n        } \r\n    */\r\n    const requestHandler = await RequestHandler.retrieveService();\r\n    try {\r\n      const { configurations } = req.body;\r\n      const result = await requestHandler.updateConfigurationsForProfile(\r\n        req.params.id,\r\n        configurations,\r\n      );\r\n      res.json({ success: true, ...result });\r\n    } catch (error) {\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  },\r\n);\r\n\r\n/**\r\n * Handles the request to remove configurations from a profile.\r\n * \r\n * @param {Request} req - The incoming request object.\r\n * @param {Response} res - The response object to send back to the client.\r\n */\r\nrouter.delete(\r\n  '/profile/:id/configurations',\r\n  async (req: Request, res: Response) => {\r\n    // #swagger.tags = ['Contract']\r\n    const requestHandler = await RequestHandler.retrieveService();\r\n    try {\r\n      const result = await requestHandler.removeConfigurationsFromProfile(\r\n        req.params.id,\r\n      );\r\n      res.json({ success: true, ...result });\r\n    } catch (error) {\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  },\r\n);\r\n\r\nexport default router;\r\n","import { Collection, Db, Document, InsertOneResult, MatchKeysAndValues, MongoClient, ObjectId, WithId } from 'mongodb';\r\nimport { DataProvider } from './DataProvider';\r\nimport { DataProviderConfig, FilterCondition, FilterOperator, SearchCriteria } from './types';\r\nimport { Logger } from './Logger';\r\n\r\ntype DocumentChangeHandler = (collectionName: string, document: any) => void;\r\n\r\nclass MongoInterceptor {\r\n  private static instance: MongoInterceptor;\r\n  private callbacks: Map<string, DocumentChangeHandler[]>;\r\n\r\n  private constructor() {\r\n    this.callbacks = new Map();\r\n    ['insert', 'update', 'delete'].forEach((op) => {\r\n      this.callbacks.set(op, []);\r\n    });\r\n  }\r\n\r\n  static getInstance(): MongoInterceptor {\r\n    if (!MongoInterceptor.instance) {\r\n      MongoInterceptor.instance = new MongoInterceptor();\r\n    }\r\n    return MongoInterceptor.instance;\r\n  }\r\n\r\n  public addCallback(\r\n    changeType: string,\r\n    callback: DocumentChangeHandler,\r\n  ): void {\r\n    const callbacks = this.callbacks.get(changeType) || [];\r\n    callbacks.push(callback);\r\n    this.callbacks.set(changeType, callbacks);\r\n  }\r\n\r\n  public notifyCallbacks(\r\n    changeType: string,\r\n    collectionName: string,\r\n    document: any,\r\n  ): void {\r\n    const callbacks = this.callbacks.get(changeType) || [];\r\n    callbacks.forEach((callback) => callback(collectionName, document));\r\n  }\r\n}\r\n\r\nexport class ChangeStreamDataProvider extends DataProvider {\r\n  private static connections: Map<\r\n        string,\r\n        { db: Db; client: MongoClient } | undefined\r\n    > = new Map();\r\n  private db?: Db;\r\n  private client?: MongoClient;\r\n  private collection!: Collection<Document>;\r\n  private dbName: string;\r\n  private connectionPromise?: Promise<Db>;\r\n\r\n  constructor(config: DataProviderConfig) {\r\n    super(config.source);\r\n    this.dbName = config.dbName;\r\n    this.connectionPromise = this.connectToDatabase(config.url);\r\n  }\r\n\r\n  private async connectToDatabase(url: string): Promise<Db> {\r\n    if (!url) {\r\n      throw new Error('Database URL is required');\r\n    }\r\n\r\n    const connectionKey = `${url}:${this.dbName}`;\r\n    const existingConnection = ChangeStreamDataProvider.connections.get(connectionKey);\r\n    if (existingConnection) {\r\n      Logger.info('Reusing existing MongoDB connection');\r\n      this.db = existingConnection.db;\r\n      this.client = existingConnection.client;\r\n      return this.db;\r\n    }\r\n\r\n    try {\r\n      const client = await MongoClient.connect(url);\r\n      const db = client.db(this.dbName);\r\n\r\n      Logger.info('MongoDB connected successfully');\r\n      this.db = db;\r\n      this.client = client;\r\n\r\n      ChangeStreamDataProvider.connections.set(connectionKey, { db, client });\r\n      return db;\r\n    } catch (error) {\r\n      Logger.error(`Error connecting to MongoDB: ${(error as Error).message}`);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public static async disconnectFromDatabase(\r\n    url: string,\r\n    dbName: string,\r\n  ): Promise<void> {\r\n    const connectionKey = `${url}:${dbName}`;\r\n    const existingConnection = ChangeStreamDataProvider.connections.get(connectionKey);\r\n\r\n    if (existingConnection) {\r\n      try {\r\n        await existingConnection.client.close();\r\n        ChangeStreamDataProvider.connections.set(connectionKey, undefined);\r\n        Logger.info(`MongoDB connection for ${connectionKey} closed`);\r\n      } catch (error) {\r\n        Logger.error(`Error during disconnect: ${(error as Error).message}`);\r\n      }\r\n    } else {\r\n      Logger.warn(`No active connection found for ${connectionKey}`);\r\n    }\r\n  }\r\n\r\n  async ensureReady(): Promise<void> {\r\n    await this.connectionPromise;\r\n    this.collection = ChangeStreamDataProvider.createCollectionProxy(\r\n            this.db!.collection(this.dataSource),\r\n    );\r\n    this.setupCallbacks();\r\n  }\r\n\r\n  private static createCollectionProxy(collection: Collection): Collection {\r\n    const interceptor = MongoInterceptor.getInstance();\r\n\r\n    const changeStream = collection.watch();\r\n    // Listen for change events\r\n    changeStream.on('change', (change) => {\r\n      // Handle different types of changes\r\n      switch (change.operationType) {\r\n        case 'insert':\r\n          interceptor.notifyCallbacks('insert', collection.collectionName, {\r\n            fullDocument: change.fullDocument,\r\n            insertedId: change.documentKey,\r\n            acknowledged: change.ns,\r\n          });\r\n          break;\r\n        case 'update':\r\n          interceptor.notifyCallbacks('update', collection.collectionName, {\r\n            filter: change.documentKey,\r\n            update: change.updateDescription,\r\n            change,\r\n          });\r\n          break;\r\n        case 'delete':\r\n          interceptor.notifyCallbacks('delete', collection.collectionName, {\r\n            filter: change.documentKey,\r\n            change,\r\n          });\r\n          break;\r\n      }\r\n    });\r\n\r\n    const handler = {\r\n      get(target: Collection, prop: string | symbol): any {\r\n        const original = target[prop as keyof Collection];\r\n        if (typeof original !== 'function') return original;\r\n\r\n        const nonAsyncMethods = ['find', 'aggregate'];\r\n\r\n        if (nonAsyncMethods.includes(prop as string)) {\r\n          return function (this: Collection, ...args: any[]) {\r\n            return (original as Function).call(target, ...args);\r\n          };\r\n        }\r\n\r\n        return async function (this: any, ...args: any[]) {\r\n          const method = original as (...args: any[]) => Promise<any>;\r\n          const result = await method.apply(target, args);\r\n\r\n          return result;\r\n        };\r\n      },\r\n    };\r\n\r\n    return new Proxy(collection, handler);\r\n  }\r\n\r\n  private setupCallbacks(): void {\r\n    const interceptor = MongoInterceptor.getInstance();\r\n\r\n    interceptor.addCallback('insert', (collectionName, data) => {\r\n      if (collectionName === this.dataSource) {\r\n        this.notifyDataChange('dataInserted', {\r\n          fullDocument: data.fullDocument,\r\n          fullDocuments: data.fullDocuments,\r\n          source: this.dataSource,\r\n        });\r\n      }\r\n    });\r\n\r\n    interceptor.addCallback('update', (collectionName, data) => {\r\n      if (collectionName === this.dataSource) {\r\n        this.notifyDataChange('dataUpdated', {\r\n          documentKey: { _id: data.filter._id },\r\n          updateDescription: { updatedFields: data.update.$set || data.update.updatedFields || {} },\r\n          source: this.dataSource,\r\n        });\r\n      }\r\n    });\r\n\r\n    interceptor.addCallback('delete', (collectionName, data) => {\r\n      if (collectionName === this.dataSource) {\r\n        this.notifyDataChange('dataDeleted', {\r\n          documentKey: { _id: data.filter._id },\r\n          source: this.dataSource,\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  protected makeQuery(conditions: FilterCondition[]): Record<string, any> {\r\n    return conditions.reduce((query, condition) => {\r\n      switch (condition.operator) {\r\n        case FilterOperator.IN:\r\n          return {\r\n            ...query,\r\n            [condition.field]: { $in: condition.value },\r\n          };\r\n        case FilterOperator.EQUALS:\r\n          return {\r\n            ...query,\r\n            [condition.field]: condition.value,\r\n          };\r\n        case FilterOperator.GT:\r\n          return {\r\n            ...query,\r\n            [condition.field]: { $gt: condition.value },\r\n          };\r\n        case FilterOperator.LT:\r\n          return {\r\n            ...query,\r\n            [condition.field]: { $lt: condition.value },\r\n          };\r\n        case FilterOperator.CONTAINS:\r\n          return {\r\n            ...query,\r\n            [condition.field]: {\r\n              $in: Array.isArray(condition.value)\r\n                ? condition.value\r\n                : [condition.value],\r\n            },\r\n          };\r\n        case FilterOperator.REGEX:\r\n          return {\r\n            ...query,\r\n            [condition.field]: {\r\n              $in: Array.isArray(condition.value)\r\n                ? condition.value.map((val) => new RegExp(val, 'i'))\r\n                : [new RegExp(condition.value, 'i')],\r\n            },\r\n          };\r\n        default:\r\n          throw new Error(`Unsupported operator: ${condition.operator}`);\r\n      }\r\n    }, {});\r\n  }\r\n\r\n  async create(data: Document): Promise<WithId<Document>> {\r\n    try {\r\n      const result: InsertOneResult<Document> =\r\n                await this.collection.insertOne(data);\r\n      if (!result.acknowledged) {\r\n        throw new Error('Document insertion was not acknowledged');\r\n      }\r\n      return { ...data, _id: result.insertedId };\r\n    } catch (error) {\r\n      Logger.info(\r\n        `Error during document insertion: ${(error as Error).message}`,\r\n      );\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async delete(id: string): Promise<boolean> {\r\n    try {\r\n      \r\n      const result = await this.collection.deleteOne({ _id: new ObjectId(id) });\r\n\r\n      if (result.deletedCount === 0) {\r\n        Logger.warn(`No document found with id: ${id}`);\r\n        return false;\r\n      }\r\n\r\n      Logger.info(`Document with id: ${id} successfully deleted`);\r\n      return true;\r\n    } catch (error) {\r\n      Logger.error(\r\n        `Error during document deletion: ${(error as Error).message}`,\r\n      );\r\n      throw error;\r\n    }\r\n  }\r\n  async find(criteria: SearchCriteria): Promise<[]> {\r\n    const query = this.makeQuery(criteria.conditions);\r\n    const data = (await this.collection\r\n      .find(query)\r\n      .limit(criteria.limit || 0)\r\n      .toArray()) as Array<{ _id?: any; [key: string]: any }>;\r\n    return data.map((item) => {\r\n      if (item._id) {\r\n        const { _id, ...rest } = item;\r\n        return {\r\n          _id: _id.toString(),\r\n          ...rest,\r\n        };\r\n      }\r\n      return item;\r\n    }) as [];\r\n  }\r\n\r\n  async update(criteria: SearchCriteria, data: unknown): Promise<boolean> {\r\n    try {\r\n      const updateData = data as MatchKeysAndValues<Document>;\r\n      const query = this.makeQuery(criteria.conditions);\r\n      const result = await this.collection.updateOne(query, {\r\n        $set: updateData,\r\n      });\r\n      if (result.matchedCount === 0) {\r\n        Logger.warn(`No document found matching the criteria`);\r\n        return false;\r\n      }\r\n      if (result.modifiedCount === 0) {\r\n        Logger.info(`No changes made to document`);\r\n        return false;\r\n      }\r\n      Logger.info(`Document successfully updated`);\r\n      return true;\r\n    } catch (error) {\r\n      Logger.error(`Error during document update: ${(error as Error).message}`);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async findAll(): Promise<any> {\r\n    return (this.collection\r\n      .find().toArray());\r\n  }\r\n\r\n  async findOne(criteria: SearchCriteria): Promise<any> {\r\n    const query = this.makeQuery(criteria.conditions);\r\n    const data = (await this.collection\r\n      .findOne(query));\r\n    return data;\r\n  }\r\n\r\n  async findOneAndUpdate(criteria: SearchCriteria, data: any): Promise<any> {\r\n    const query = this.makeQuery(criteria.conditions);\r\n    return (await this.collection\r\n      .findOneAndUpdate(query, { $set: data }, { returnDocument: 'after' }));\r\n  }\r\n\r\n  async findOneAndPush(criteria: SearchCriteria, data: any): Promise<any> {\r\n    const query = this.makeQuery(criteria.conditions);\r\n    Object.keys(data).map((key: string) => {\r\n      data[key].map((element: { _id: ObjectId; }) => element._id = new ObjectId());\r\n      data[key] = { $each: data[key] };\r\n    })\r\n    return (await this.collection\r\n      .findOneAndUpdate(query, { $push: data }, { returnDocument: 'after' }));\r\n  }\r\n\r\n  async findOneAndPull(criteria: SearchCriteria, data: any): Promise<any> {\r\n    const query = this.makeQuery(criteria.conditions);\r\n    return (await this.collection\r\n      .findOneAndUpdate(query, { $pull: data }, { returnDocument: 'after' }));\r\n  }\r\n}\r\n","import { Profile, ProfileJSON } from './Profile';\r\nimport {\r\n  ProfileDocument,\r\n  SearchCriteria,\r\n  DataChangeEvent,\r\n  PreferencePayload,\r\n  ProfilePayload,\r\n  CAECode,\r\n  ConsentAgentError,\r\n  FilterOperator,\r\n  ProfilePreference,\r\n} from './types';\r\nimport { Agent } from './Agent';\r\nimport { DataProvider, DataProviderType } from './DataProvider';\r\nimport { Logger } from './Logger';\r\nimport { ChangeStreamDataProvider } from './ChangeStreamDataProvider';\r\nimport axios from 'axios';\r\nimport { ObjectId } from 'mongodb';\r\n\r\nexport class ConsentAgent extends Agent {\r\n  private static instance: ConsentAgent | null = null;\r\n\r\n  private constructor() {\r\n    super();\r\n  }\r\n\r\n  /**\r\n   * Prepares the ConsentAgent instance by loading configuration and setting up providers\r\n   * @throws {ConsentAgentError} If preparation fails\r\n   */\r\n  async prepare(): Promise<void> {\r\n    try {\r\n      this.loadDefaultConfiguration();\r\n      await this.addDefaultProviders();\r\n      this.setupProviderEventHandlers();\r\n    } catch (error) {\r\n      const agentError: ConsentAgentError = {\r\n        name: 'PreparationError',\r\n        message: `Failed to prepare ConsentAgent: ${(error as Error).message}`,\r\n        code: CAECode.PREPARATION_FAILED,\r\n      };\r\n      Logger.error(agentError.message);\r\n      throw agentError;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieves or creates an instance of ConsentAgent.\r\n   * @param dataProviderType\r\n   * @param refresh - Whether to force creation of a new instance.\r\n   * @returns Instance of ConsentAgent.\r\n   */\r\n  static async retrieveService(\r\n    dataProviderType: DataProviderType = ChangeStreamDataProvider,\r\n    refresh: boolean = false,\r\n  ): Promise<ConsentAgent> {\r\n    try {\r\n      if (!ConsentAgent.instance || refresh) {\r\n        DataProvider.setChildType(dataProviderType);\r\n        const instance = new ConsentAgent();\r\n        await instance.prepare();\r\n        ConsentAgent.instance = instance;\r\n      }\r\n      return ConsentAgent.instance;\r\n    } catch (error) {\r\n      const serviceError: ConsentAgentError = {\r\n        name: 'ServiceRetrievalError',\r\n        message: `Failed to retrieve ConsentAgent service: ${(error as Error).message}`,\r\n        code: CAECode.SERVICE_RETRIEVAL_FAILED,\r\n      };\r\n      Logger.error(serviceError.message);\r\n      throw serviceError;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Finds profiles based on the provided source and search criteria.\r\n   * @param source - Data source identifier.\r\n   * @param criteria - Search criteria.\r\n   * @returns Promise resolving to an array of profiles.\r\n   */\r\n  async findProfiles(\r\n    source: string,\r\n    criteria: SearchCriteria,\r\n  ): Promise<Profile[]> {\r\n    try {\r\n      const dataProvider = this.getDataProvider(source);\r\n      const results: ProfileDocument[] = await dataProvider.find(criteria);\r\n      return results.map((result) => {\r\n        const profil = {\r\n          uri: result.uri,\r\n          configurations: result.configurations,\r\n          recommendations: result.recommendations || [],\r\n          matching: result.matching || [],\r\n          preference: result.preference || [],\r\n        };\r\n        return new Profile(profil);\r\n      });\r\n    } catch (error) {\r\n      Logger.error(`Error while finding profile: ${(error as Error).message}`);\r\n      throw new Error();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Finds profile based on the provided source and search criteria.\r\n   * @param source - Data source identifier.\r\n   * @param criteria - Search criteria.\r\n   * @returns Promise resolving to an array of profiles.\r\n   */\r\n  async findProfile(\r\n    source: string,\r\n    criteria: SearchCriteria,\r\n  ): Promise<Profile> {\r\n    try {\r\n      const dataProvider = this.getDataProvider(source);\r\n      const result: ProfileDocument = await dataProvider.findOne(criteria);\r\n      return new Profile({\r\n        _id: result?._id,\r\n        uri: result?.uri,\r\n        configurations: result?.configurations,\r\n        recommendations: result?.recommendations || [],\r\n        matching: result?.matching || [],\r\n        preference: result?.preference || [],\r\n      });\r\n    } catch (error) {\r\n      Logger.error(`Error while finding profile: ${(error as Error).message}`);\r\n      throw new Error();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Finds profile based on the provided source and search criteria.\r\n   * @param source - Data source identifier.\r\n   * @param criteria - Search criteria.\r\n   * @param data - the updated data\r\n   * @returns Promise resolving to an array of profiles.\r\n   */\r\n  async findProfileAndUpdate(\r\n    source: string,\r\n    criteria: SearchCriteria,\r\n    data: ProfilePayload | PreferencePayload | ProfileDocument,\r\n  ): Promise<Profile> {\r\n    try {\r\n      const dataProvider = this.getDataProvider(source);\r\n      const result: ProfileDocument = await dataProvider.findOneAndUpdate(\r\n        criteria,\r\n        data,\r\n      );\r\n      return new Profile({\r\n        uri: result.uri,\r\n        configurations: result.configurations,\r\n        recommendations: result.recommendations || [],\r\n        matching: result.matching || [],\r\n        preference: result.preference || [],\r\n      });\r\n    } catch (error) {\r\n      Logger.error(`Error while finding profile: ${(error as Error).message}`);\r\n      throw new Error();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Finds profile based on the provided source and search criteria.\r\n   * @param source - Data source identifier.\r\n   * @param criteria - Search criteria.\r\n   * @param data - the updated data\r\n   * @returns Promise resolving to an array of profiles.\r\n   */\r\n  async findProfileAndPush(\r\n    source: string,\r\n    criteria: SearchCriteria,\r\n    data: ProfilePayload,\r\n  ): Promise<Profile> {\r\n    try {\r\n      const dataProvider = this.getDataProvider(source);\r\n      const result: ProfileDocument = await dataProvider.findOneAndPush(\r\n        criteria,\r\n        data,\r\n      );\r\n      return new Profile({\r\n        uri: result.uri,\r\n        configurations: result.configurations,\r\n        recommendations: result.recommendations || [],\r\n        matching: result.matching || [],\r\n        preference: result.preference || [],\r\n      });\r\n    } catch (error) {\r\n      Logger.error(`Error while finding profile: ${(error as Error).message}`);\r\n      throw new Error();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Finds profile based on the provided source and search criteria.\r\n   * @param source - Data source identifier.\r\n   * @param criteria - Search criteria.\r\n   * @param data - the updated data\r\n   *   Promise resolving to an array of profiles.\r\n   */\r\n  async findProfileAndPull(\r\n    source: string,\r\n    criteria: SearchCriteria,\r\n    data: any,\r\n  ): Promise<Profile> {\r\n    try {\r\n      const dataProvider = this.getDataProvider(source);\r\n      const result: ProfileDocument = await dataProvider.findOneAndPull(\r\n        criteria,\r\n        data,\r\n      );\r\n      return new Profile({\r\n        uri: result.uri,\r\n        configurations: result.configurations,\r\n        recommendations: result.recommendations || [],\r\n        matching: result.matching || [],\r\n        preference: result.preference || [],\r\n      });\r\n    } catch (error) {\r\n      Logger.error(`Error while finding profile: ${(error as Error).message}`);\r\n      throw new Error();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Builds search criteria based on the provided source entity.\r\n   * @param sourceEntity - Entity from which to derive search criteria.\r\n   * @returns The constructed search criteria.\r\n   */\r\n  protected buildSearchCriteria(sourceEntity: unknown): SearchCriteria {\r\n    throw new Error('Method not implemented.');\r\n  }\r\n\r\n  /**\r\n   * Enriches a profile with system recommendations.\r\n   * @returns The enriched profile.\r\n   */\r\n  protected enrichProfileWithSystemRecommendations(): Profile {\r\n    throw new Error('Method not implemented.');\r\n  }\r\n\r\n  /**\r\n   * Handles inserted data events\r\n   * @param data - Data change event\r\n   */\r\n  protected async handleDataInserted(data: DataChangeEvent): Promise<void> {\r\n    if (data.fullDocument && data.fullDocument instanceof Object) {\r\n      switch (data.source) {\r\n        case 'users':\r\n          {\r\n            try {\r\n              const { _id } = data.fullDocument as any;\r\n              await this.createProfileForParticipant(_id);\r\n              Logger.info(`Data inserted for source: ${data.source}`);\r\n            } catch (error) {\r\n              Logger.error(\r\n                `Data insertion failed: ${(error as Error).message}`,\r\n              );\r\n              throw error;\r\n            }\r\n          }\r\n          break;\r\n        case 'privacynotices':\r\n          {\r\n            try {\r\n              //update data exchanges recommendation profiles\r\n              await this.handlePrivacyNotice(data.fullDocument);\r\n              Logger.info(`Data inserted for source: ${data.source}`);\r\n            } catch (error) {\r\n              Logger.error(\r\n                `Data insertion failed: ${(error as Error).message}`,\r\n              );\r\n              throw error;\r\n            }\r\n          }\r\n          break;\r\n        case 'consents':\r\n          {\r\n            try {\r\n              //update consents recommendation profiles\r\n              await this.handleConsent(data.fullDocument);\r\n              Logger.info(`Data inserted for source: ${data.source}`);\r\n            } catch (error) {\r\n              Logger.error(\r\n                `Data insertion failed: ${(error as Error).message}`,\r\n              );\r\n              throw error;\r\n            }\r\n          }\r\n          break;\r\n      }\r\n    } else {\r\n      Logger.info(`Unhandled data for source: ${data.source}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handles data update events.\r\n   * @param data - Data change event.\r\n   */\r\n  protected async handleDataUpdated(data: DataChangeEvent): Promise<void> {\r\n    if (data.updateDescription && data.updateDescription.updatedFields && data.updateDescription.updatedFields instanceof Object) {\r\n      switch (data.source) {\r\n        case 'users':\r\n          {\r\n            try {\r\n              //update profiles\r\n              // watch for new identifier\r\n              if((data.updateDescription.updatedFields as any).identifiers) await this.handleNewIdentifier({ _id: data.documentKey?._id });\r\n              Logger.info(`Data updated for source: ${data.source}`);\r\n            } catch (error) {\r\n              Logger.error(\r\n                `Data update failed: ${(error as Error).message}`,\r\n              );\r\n              throw error;\r\n            }\r\n          }\r\n          break;\r\n        case 'consents':\r\n          {\r\n            try {\r\n              const { updatedFields } = data.updateDescription as any\r\n              //watch for revoked consent\r\n              if (updatedFields.status && (updatedFields.status === 'revoked' || updatedFields.status === 'refused' || updatedFields.status === 'terminated')) {\r\n                //update profiles\r\n                //remove element from profiles\r\n                await this.handleRemoveConsent({ _id: data.documentKey?._id });\r\n              }\r\n              Logger.info(`Data updated for source: ${data.source}`);\r\n            } catch (error) {\r\n              Logger.error(\r\n                `Data update failed: ${(error as Error).message}`,\r\n              );\r\n              throw error;\r\n            }\r\n          }\r\n          break;\r\n      }\r\n    } else {\r\n      Logger.info(`Unhandled data for source: ${data.source}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handles data deletion events.\r\n   * @param data - Data change event.\r\n   */\r\n  protected async handleDataDeleted(data: DataChangeEvent): Promise<void> {\r\n    if (data.documentKey && data.documentKey instanceof Object) {\r\n      switch (data.source) {\r\n        case 'users':\r\n          {\r\n            try {\r\n              const { _id } = data.documentKey as any;\r\n              await this.deleteProfileForParticipant(_id);\r\n              Logger.info(`Data deleted for source: ${data.source}`);\r\n            } catch (error) {\r\n              Logger.error(\r\n                `Data deletion failed: ${(error as Error).message}`,\r\n              );\r\n              throw error;\r\n            }\r\n          }\r\n          break;\r\n        case 'privacynotices':\r\n          {\r\n            try {\r\n              //update profiles\r\n              //remove element from profiles\r\n              await this.handleRemovePrivacyNotice(data.documentKey);\r\n              Logger.info(`Data deleted for source: ${data.source}`);\r\n            } catch (error) {\r\n              Logger.error(\r\n                `Data deletion failed: ${(error as Error).message}`,\r\n              );\r\n              throw error;\r\n            }\r\n          }\r\n          break;\r\n        case 'consents':\r\n          {\r\n            try {\r\n              //update profiles\r\n              //remove element from profiles\r\n              await this.handleRemoveConsent(data.documentKey);\r\n              Logger.info(`Data deleted for source: ${data.source}`);\r\n            } catch (error) {\r\n              Logger.error(\r\n                `Data deletion failed: ${(error as Error).message}`,\r\n              );\r\n              throw error;\r\n            }\r\n          }\r\n          break;\r\n      }\r\n    } else {\r\n      Logger.info(`Unhandled data insertion for source: ${data.source}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the matching information for a profile.\r\n   * @param profile - Profile instance.\r\n   * @param data - Matching data to update the profile with.\r\n   */\r\n  protected async updateMatchingForProfile(\r\n    profile: Profile,\r\n    data: unknown,\r\n  ): Promise<void> {\r\n    throw new Error('Method not implemented.');\r\n  }\r\n\r\n  /**\r\n   * Check the existing data at the Agent initialization\r\n   * @returns {Promise<void>}\r\n   */\r\n  protected async existingDataCheck(): Promise<void> {\r\n    const users = await this.getDataProvider('users').findAll();\r\n    const profiles = await this.getDataProvider('profiles').findAll();\r\n\r\n    for (const user of users) {\r\n      const existingProfile = profiles.find(\r\n        (profile) => profile.uri.toString() === user._id.toString(),\r\n      );\r\n\r\n      if (!existingProfile) {\r\n        await this.createProfileForParticipant(user._id);\r\n        Logger.info(`Profile created for user - ${user._id}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates recommendations for a profile.\r\n   * @param profile - Profile instance.\r\n   * @param data - Recommendation data to update the profile with.\r\n   */\r\n  protected async updateRecommendationForProfile(\r\n    profile: Profile,\r\n    data: ProfileDocument,\r\n  ): Promise<void> {\r\n    const dataProvider = this.getDataProvider('profiles');\r\n    const criteria: SearchCriteria = {\r\n      conditions: [\r\n        {\r\n          field: '_id',\r\n          operator: FilterOperator.EQUALS,\r\n          value: profile._id,\r\n        },\r\n      ],\r\n      threshold: 0,\r\n    };\r\n    await dataProvider.findOneAndUpdate(criteria, data);\r\n  }\r\n\r\n  /**\r\n   * Create a profile for a user\r\n   * @param participantId - The Id of the user\r\n   * @param allowRecommendations - boolean option to setup configuration of the profile at the creation\r\n   */\r\n  public async createProfileForParticipant(\r\n    participantId: string,\r\n    allowRecommendations?: boolean,\r\n  ): Promise<Profile> {\r\n    try {\r\n      const profileProvider = this.getDataProvider('profiles');\r\n      const newProfileData = {\r\n        uri: participantId.toString(),\r\n        configurations: {\r\n          allowRecommendations: allowRecommendations ?? true,\r\n        },\r\n        recommendations: {\r\n          consents: [] as unknown,\r\n          dataExchanges: [] as unknown,\r\n        },\r\n        preference: [] as unknown,\r\n      };\r\n      const profile = await profileProvider.create(newProfileData);\r\n      return new Profile(profile as ProfileJSON);\r\n    } catch (error) {\r\n      Logger.error(`Error creating profile: ${(error as Error).message}`);\r\n      throw new Error('Profile creation failed');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Deletes a profile for a given participant.\r\n   * \r\n   * @param participantId - The Id of the participant whose profile is to be deleted.\r\n   * @returns The deleted profile.\r\n   */\r\n  public async deleteProfileForParticipant(\r\n    participantId: string,\r\n  ): Promise<Profile> {\r\n    try {\r\n      const profileProvider = this.getDataProvider('profiles');\r\n      const result: ProfileDocument = await profileProvider.findOne({\r\n        conditions: [\r\n          {\r\n            field: 'uri',\r\n            operator: FilterOperator.EQUALS,\r\n            value: participantId,\r\n          },\r\n        ],\r\n        threshold: 0,\r\n      });\r\n      if (result._id) {\r\n        await profileProvider.delete(result?._id);\r\n        return new Profile({\r\n          uri: result.uri,\r\n          configurations: result.configurations,\r\n          recommendations: result.recommendations || [],\r\n          matching: result.matching || [],\r\n          preference: result.preference || [],\r\n        });\r\n      } else {\r\n        throw new Error('Profile not found');\r\n      }\r\n    } catch (error) {\r\n      Logger.error(`Error creating profile: ${(error as Error).message}`);\r\n      throw new Error('Profile creation failed');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handles privacy notices by updating profiles that allow recommendations.\r\n   * \r\n   * This method processes the privacy notice document by first fetching the purpose and data information.\r\n   * It then retrieves all profiles that allow recommendations and checks if they match the participants or categories\r\n   * specified in the purpose and data. If a match is found, the method updates the profile by adding the privacy notice.\r\n   * \r\n   * @param fullDocument - The full document containing the privacy notice information.\r\n   */\r\n  public async handlePrivacyNotice(fullDocument: any) {\r\n    // Fetch purpose and data information\r\n    const purposeData = await this.getPurposeAndData(\r\n      fullDocument.purposes[0].serviceOffering,\r\n      fullDocument.data[0].serviceOffering,\r\n    );\r\n\r\n    if (!purposeData) {\r\n      throw new Error('Purpose and data information is undefined');\r\n    }\r\n    \r\n    const { purpose, data } = purposeData;\r\n\r\n    // Retrieve profiles that allow recommendations\r\n    const profileProvider = this.getDataProvider('profiles');\r\n    const allProfiles = await profileProvider.findAll();\r\n\r\n    for (const profile of allProfiles) {\r\n      if (\r\n        profile.configurations.allowRecommendations &&\r\n        profile.preference.some(\r\n          (pref: ProfilePreference) =>\r\n            pref.participant === purpose.providedBy ||\r\n            pref.participant === data.providedBy ||\r\n            (pref.category && purpose.category.includes(pref.category)) ||\r\n            (pref.category && data.category.includes(pref.category))\r\n        )\r\n      ) {\r\n        // Update profile\r\n        const { recommendations } = profile;\r\n        recommendations.dataExchanges.push(fullDocument._id);\r\n        await this.updateRecommendationForProfile(profile, profile);\r\n        Logger.info(\r\n          `Profile ${profile._id} updated with privacy notice ${fullDocument._id}`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  \r\n  /**\r\n   * Handles consent by updating profiles that allow recommendations.\r\n   * \r\n   * This method processes the consent document by first fetching the purpose and data information.\r\n   * It then retrieves all profiles that allow recommendations and checks if they match the participants or categories\r\n   * specified in the purpose and data. If a match is found, the method updates the profile by removing the privacy notice\r\n   * and adding the consent.\r\n   * \r\n   * @param fullDocument - The full document containing the consent information.\r\n   */\r\n  public async handleConsent(fullDocument: any) {\r\n    // Fetch purpose and data information\r\n    const purposeData = await this.getPurposeAndData(\r\n      fullDocument.purposes[0].serviceOffering,\r\n      fullDocument.data[0].serviceOffering,\r\n    );\r\n\r\n    if (!purposeData) {\r\n      throw new Error('Purpose and data information is undefined');\r\n    }\r\n    \r\n    const { purpose, data } = purposeData;\r\n\r\n    // Retrieve profiles that allow recommendations\r\n    const profileProvider = this.getDataProvider('profiles');\r\n    const allProfiles = await profileProvider.findAll();\r\n\r\n    for (const profile of allProfiles) {\r\n      if (\r\n        profile.configurations.allowRecommendations &&\r\n        profile.preference.some(\r\n          (pref: ProfilePreference) =>\r\n            pref.participant === purpose.providedBy ||\r\n            pref.participant === data.providedBy ||\r\n            (pref.category && purpose.category.includes(pref.category)) ||\r\n            (pref.category && data.category.includes(pref.category))\r\n        )\r\n      ) {\r\n        // Update profile\r\n        // Remove privacy notice\r\n        const index = profile.recommendations.dataExchanges.indexOf(\r\n          fullDocument.privacyNotice,\r\n        );\r\n        profile.recommendations.dataExchanges.splice(index, 1);\r\n        // Add consent\r\n        profile.recommendations.consents.push(fullDocument._id);\r\n        await this.updateRecommendationForProfile(profile, profile);\r\n        Logger.info(\r\n          `Profile ${profile._id} updated with consent ${fullDocument._id}`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handles the removal of privacy notice from profiles.\r\n   * @param fullDocument - The full document containing the privacy notice information.\r\n   */\r\n  public async handleRemovePrivacyNotice(fullDocument: any) {\r\n    // Retrieve profiles that allow recommendations\r\n    const profileProvider = this.getDataProvider('profiles');\r\n    const allProfiles = await profileProvider.findAll();\r\n\r\n    for (const profile of allProfiles) {\r\n      const { recommendations } = profile;\r\n      if (\r\n        recommendations.dataExchanges.includes(fullDocument._id)\r\n      ) {\r\n        // Update profile\r\n        const pull = { 'recommendations.dataExchanges': { '_id': new ObjectId(fullDocument._id) } }\r\n        const criteria: SearchCriteria = {\r\n          conditions: [\r\n            {\r\n              field: 'uri',\r\n              operator: FilterOperator.EQUALS,\r\n              value: profile.uri,\r\n            }\r\n          ],\r\n          threshold: 0,\r\n        };\r\n        await this.findProfileAndPull('profiles', criteria, pull);\r\n        Logger.info(\r\n          `Profile ${profile._id} updated with privacy notice ${fullDocument._id}`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handles the removal of consent from profiles.\r\n   * @param fullDocument - The full document containing the consent information.\r\n   */\r\n  public async handleRemoveConsent(fullDocument: any) {\r\n    // Retrieve profiles that allow recommendations\r\n    const profileProvider = this.getDataProvider('profiles');\r\n    const allProfiles = await profileProvider.findAll();\r\n\r\n    for (const profile of allProfiles) {\r\n      const { recommendations } = profile;\r\n      if (\r\n        recommendations.consents.includes(fullDocument._id)\r\n      ) {\r\n        // Update profile\r\n        const pull = { 'recommendations.consents': { '_id': new ObjectId(fullDocument._id) } }\r\n        const criteria: SearchCriteria = {\r\n          conditions: [\r\n            {\r\n              field: 'uri',\r\n              operator: FilterOperator.EQUALS,\r\n              value: profile.uri,\r\n            }\r\n          ],\r\n          threshold: 0,\r\n        };\r\n        await this.findProfileAndPull('profiles', criteria, pull);\r\n        Logger.info(\r\n          `Profile ${profile._id} updated with privacy notice ${fullDocument._id}`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fetches purpose and data documents based on their service descriptions.\r\n   *\r\n   * @param purposeSd - The service description URL for the purpose document.\r\n   * @param dataSd - The service description URL for the data document.\r\n   * @returns An object containing the fetched purpose and data documents.\r\n   */\r\n  private async getPurposeAndData(\r\n    purposeSd: string,\r\n    dataSd: string,\r\n  ): Promise<\r\n    | {\r\n        purpose: { providedBy: string; category: string[] };\r\n        data: { providedBy: string; category: string[] };\r\n      }\r\n    | undefined\r\n  > {\r\n    try {\r\n      const [purposeResponse, dataResponse] = await Promise.all([\r\n        axios.get(purposeSd),\r\n        axios.get(dataSd),\r\n      ]);\r\n      if (!purposeResponse.data) {\r\n        throw new Error('Purpose data is undefined');\r\n      }\r\n      if (!dataResponse.data) {\r\n        throw new Error('Data data is undefined');\r\n      }\r\n      return { purpose: purposeResponse.data, data: dataResponse.data };\r\n    } catch (e) {\r\n      Logger.error(`Error fetching purpose and data: ${(e as Error).message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handles new identifier events.\r\n   * @param fullDocument - The full document of the new identifier event.\r\n   */\r\n  private async handleNewIdentifier(fullDocument: any){\r\n    try {\r\n      //find the profile\r\n      const profileProvider = this.getDataProvider('profiles');\r\n      const criteria: SearchCriteria = {\r\n        conditions: [\r\n          {\r\n            field: 'uri',\r\n            operator: FilterOperator.EQUALS,\r\n            value: fullDocument._id,\r\n          }\r\n        ],\r\n        threshold: 0,\r\n      };\r\n      const profile = await profileProvider.findOne(criteria);\r\n      if (!profile) {\r\n        throw new Error('Profile not found');\r\n      }\r\n\r\n      // Retrieve profiles that allow recommendations\r\n      const userIdentifierProvider = this.getDataProvider('useridentifiers');\r\n      const identifierCriteria: SearchCriteria = {\r\n        conditions: [\r\n          {\r\n            field: '_id',\r\n            operator: FilterOperator.EQUALS,\r\n            value: fullDocument._id,\r\n          }\r\n        ],\r\n        threshold: 0,\r\n      };\r\n      const identifier = await userIdentifierProvider.findOne(identifierCriteria);\r\n      if (!identifier) {\r\n        throw new Error('Identifier not found');\r\n      }\r\n\r\n      //find participant\r\n      const participantsProvider = this.getDataProvider('participants');\r\n      const participantCriteria: SearchCriteria = {\r\n        conditions: [\r\n          {\r\n            field: '_id',\r\n            operator: FilterOperator.EQUALS,\r\n            value: identifier.attachedParticipant,\r\n          }\r\n        ],\r\n        threshold: 0,\r\n      };\r\n      const participant = await participantsProvider.findOne(participantCriteria);\r\n      if (!participant) {\r\n        throw new Error('Participant not found');\r\n      }\r\n\r\n      //find all the privacy notices and filter\r\n      const pnProvider = this.getDataProvider('privacynotices');\r\n      const privacyNotices = await pnProvider.findAll();\r\n      if (!privacyNotices) {\r\n        throw new Error('Privacy notices not found');\r\n      }\r\n      const filteredPrivacyNotices = privacyNotices.filter((pn: {dataProvider: string, recipients: string[]}) => \r\n        pn.dataProvider === participant.selfDescriptionURL || \r\n        pn.recipients.includes(participant.selfDescriptionURL)\r\n      );\r\n\r\n      //find all the consents and filter\r\n      const consentProvider = this.getDataProvider('consents');\r\n      const consents = await consentProvider.findAll();\r\n      if (!consents) {\r\n        throw new Error('Consents not found');\r\n      }\r\n      const filteredConsents = consents.filter((consent: {dataProvider: string, dataConsumer: string}) => \r\n        consent.dataProvider === participant._id || \r\n        consent.dataConsumer === participant._id\r\n      );\r\n\r\n      //add filtered privacy notices and consents to profile\r\n      filteredPrivacyNotices.forEach((pn: {_id: string}) => {\r\n        profile.recommendations.dataExchanges.push(pn._id);\r\n        profile.recommendations.dataExchanges = [...new Set(profile.recommendations.dataExchanges)];\r\n      });\r\n\r\n      filteredConsents.forEach((consent: {_id: string}) => {\r\n        profile.recommendations.consents.push(consent._id);\r\n        profile.recommendations.consents = [...new Set(profile.recommendations.consents)];\r\n      });\r\n\r\n      await this.updateRecommendationForProfile(profile, profile);\r\n    } catch (error) {\r\n      Logger.error(`Error handling new identifier: ${(error as Error).message}`);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   *\r\n   * @param source\r\n   * @param criteria\r\n   * @param profile\r\n   */\r\n  saveProfile(\r\n    source: string,\r\n    criteria: SearchCriteria,\r\n    profile: Profile,\r\n  ): Promise<boolean> {\r\n    throw new Error('Method not implemented.');\r\n  }\r\n}\r\n","import { ConsentAgent } from './ConsentAgent';\r\nimport {\r\n  SearchCriteria,\r\n  FilterOperator,\r\n  ProfileConfigurations,\r\n  ProfileDocument,\r\n  ProfilePreference,\r\n  PreferencePayload,\r\n  Condition,\r\n  AuthorizationLevelEnum,\r\n  ConsentProfileRecommendation,\r\n} from './types';\r\nimport {  ObjectId } from 'mongodb';\r\n\r\n// Request Handler\r\nexport class ConsentAgentRequestHandler {\r\n  private consentAgent?: ConsentAgent;\r\n\r\n  private static instance: ConsentAgentRequestHandler | null = null;\r\n  private contractAgent?: ConsentAgent;\r\n  private profilesHost: string = '';\r\n  private constructor() {}\r\n\r\n  static async retrieveService(): Promise<ConsentAgentRequestHandler> {\r\n    if (!ConsentAgentRequestHandler.instance) {\r\n      const instance = new ConsentAgentRequestHandler();\r\n      await instance.prepare();\r\n      ConsentAgentRequestHandler.instance = instance;\r\n    }\r\n    return ConsentAgentRequestHandler.instance;\r\n  }\r\n\r\n  async prepare() {\r\n    this.consentAgent = await ConsentAgent.retrieveService();\r\n  }\r\n\r\n  async getConsentAgent(): Promise<ConsentAgent> {\r\n    return ConsentAgent.retrieveService();\r\n  }\r\n\r\n  /**\r\n   * Returns only the policies from the recommendations.\r\n   * \r\n   * @param profileId - The ID of the profile to retrieve recommendations for.\r\n   * @returns {Promise<any>} - A promise that resolves to the policies from the recommendations.\r\n   */\r\n  async getConsentRecommendationFromProfile(profileId: string): Promise<any> {\r\n    await this.prepare();\r\n    const criteria: SearchCriteria = {\r\n      conditions: [\r\n        {\r\n          field: 'uri',\r\n          operator: FilterOperator.EQUALS,\r\n          value: profileId,\r\n        },\r\n      ],\r\n      threshold: 0,\r\n    };\r\n\r\n    if (!this.consentAgent) {\r\n      throw new Error('Consent Agent undefined');\r\n    }\r\n    const profile = await this.consentAgent.findProfile('profiles', criteria);\r\n    if (!profile) {\r\n      throw new Error('Profile not found');\r\n    }\r\n    return (profile.recommendations as ConsentProfileRecommendation).consents;\r\n  }\r\n\r\n  /**\r\n   * Returns only the services from the recommendations.\r\n   * \r\n   * @param profileId - The ID of the profile to retrieve recommendations for.\r\n   * @returns {Promise<any>} - A promise that resolves to the services from the recommendations.\r\n   */\r\n  async getDataExchangeRecommendationFromProfile(\r\n    profileId: string,\r\n  ): Promise<any> {\r\n    await this.prepare();\r\n    const criteria: SearchCriteria = {\r\n      conditions: [\r\n        {\r\n          field: 'uri',\r\n          operator: FilterOperator.EQUALS,\r\n          value: profileId,\r\n        },\r\n      ],\r\n      threshold: 0,\r\n    };\r\n    if (!this.consentAgent) {\r\n      throw new Error('Consent Agent undefined');\r\n    }\r\n    const profile = await this.consentAgent.findProfile('profiles', criteria);\r\n    if (!profile) {\r\n      throw new Error('Profile not found');\r\n    }\r\n    return (profile.recommendations as ConsentProfileRecommendation).dataExchanges;\r\n  }\r\n\r\n  /**\r\n   * Return the profile's authorization\r\n   * @param profileURL - uri of the profile\r\n   * @return Promise<ProfilePreference[]>\r\n   */\r\n  async getPreferencesFromProfile(\r\n    profileURL: string,\r\n  ): Promise<ProfilePreference[]> {\r\n    await this.prepare();\r\n    const criteria: SearchCriteria = {\r\n      conditions: [\r\n        {\r\n          field: 'uri',\r\n          operator: FilterOperator.EQUALS,\r\n          value: profileURL,\r\n        },\r\n      ],\r\n      threshold: 0,\r\n    };\r\n    if (!this.consentAgent) {\r\n      throw new Error('Consent Agent undefined');\r\n    }\r\n    const profile = await this.consentAgent.findProfile('profiles', criteria);\r\n    if (!profile) throw new Error('Profile not found');\r\n\r\n    return profile.preference;\r\n  }\r\n\r\n  /**\r\n   * Return the profile's authorization\r\n   * @param profileURL - uri of the profile\r\n   * @param {PreferencePayload} data\r\n   * @return Promise<ProfilePreference[]>\r\n   */\r\n  async addPreferenceToProfile(\r\n    profileURL: string,\r\n    data: PreferencePayload[],\r\n  ): Promise<ProfilePreference[]> {\r\n    await this.prepare();\r\n    const criteria: SearchCriteria = {\r\n      conditions: [\r\n        {\r\n          field: 'uri',\r\n          operator: FilterOperator.EQUALS,\r\n          value: profileURL,\r\n        },\r\n      ],\r\n      threshold: 0,\r\n    };\r\n    if (!this.consentAgent) {\r\n      throw new Error('Consent Agent undefined');\r\n    }\r\n    const profile = await this.consentAgent.findProfileAndPush(\r\n      'profiles',\r\n      criteria,\r\n      { preference: data },\r\n    );\r\n    if (!profile) throw new Error('Profile not found');\r\n\r\n    return profile.preference;\r\n  }\r\n\r\n  /**\r\n   * Return the profile's authorization\r\n   * @param {string} profileURL - URL of the profile\r\n   * @param {string} preferenceId - ID of the preference\r\n   * @return Promise<ProfilePreference[]>\r\n   */\r\n  async getPreferenceByIdFromProfile(\r\n    profileURL: string,\r\n    preferenceId: string,\r\n  ): Promise<ProfilePreference[]> {\r\n    await this.prepare();\r\n    const criteria: SearchCriteria = {\r\n      conditions: [\r\n        {\r\n          field: 'uri',\r\n          operator: FilterOperator.EQUALS,\r\n          value: profileURL,\r\n        },\r\n      ],\r\n      threshold: 0,\r\n    };\r\n    if (!this.consentAgent) {\r\n      throw new Error('Consent Agent undefined');\r\n    }\r\n    const profile = await this.consentAgent.findProfile('profiles', criteria);\r\n    if (!profile) throw new Error('Profile not found');\r\n\r\n    return profile.preference.filter(\r\n      (element) => element._id?.toString() === preferenceId,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Update the profile's preference\r\n   * @param {string} profileURL - URL of the profile\r\n   * @param {string} preferenceId - ID of the preference\r\n   * @param {PreferencePayload} data - Data to update\r\n   * @return Promise<ProfilePreference[]>\r\n   */\r\n  async updatePreferenceByIdFromProfile(\r\n    profileURL: string,\r\n    preferenceId: string,\r\n    data: PreferencePayload,\r\n  ): Promise<ProfilePreference[]> {\r\n    await this.prepare();\r\n    const criteria: SearchCriteria = {\r\n      conditions: [\r\n        {\r\n          field: 'uri',\r\n          operator: FilterOperator.EQUALS,\r\n          value: profileURL,\r\n        },\r\n      ],\r\n      threshold: 0,\r\n    };\r\n    if (!this.consentAgent) {\r\n      throw new Error('Consent Agent undefined');\r\n    }\r\n    const profile = await this.consentAgent.findProfile('profiles', criteria);\r\n    if (!profile) throw new Error('Profile not found');\r\n\r\n    const preferenceIndex = profile.preference.findIndex(\r\n      (element) => element._id?.toString() === preferenceId,\r\n    );\r\n\r\n    if(data.asDataProvider){\r\n      profile.preference[preferenceIndex].asDataProvider = {\r\n        ...profile.preference[preferenceIndex].asDataProvider,\r\n        ...data.asDataProvider,\r\n      };\r\n    }\r\n\r\n    if(data.asServiceProvider){\r\n      profile.preference[preferenceIndex].asServiceProvider = {\r\n        ...profile.preference[preferenceIndex].asServiceProvider,\r\n        ...data.asServiceProvider,\r\n      };\r\n    }\r\n\r\n    if(data.participant){\r\n      profile.preference[preferenceIndex].participant = data.participant\r\n    }\r\n\r\n    if(data.category){\r\n      profile.preference[preferenceIndex].participant = data.category\r\n    }\r\n\r\n    delete profile._id;\r\n\r\n    const profileUpdated = await this.consentAgent.findProfileAndUpdate(\r\n      'profiles',\r\n      criteria,\r\n      profile,\r\n    );\r\n    if (!profileUpdated) throw new Error('Profile not found');\r\n    return profileUpdated.preference.filter(\r\n      (element) => element._id?.toString() === preferenceId,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Update the profile's preference\r\n   * @param {string} profileURL - URL of the profile\r\n   * @param {string} preferenceId - ID of the preference\r\n   * @param {PreferencePayload} data - Data to update\r\n   * @return Promise<ProfilePreference[]>\r\n   */\r\n  async deletePreferenceByIdFromProfile(\r\n    profileURL: string,\r\n    preferenceId: string,\r\n  ): Promise<ProfilePreference[]> {\r\n    await this.prepare();\r\n    const criteria: SearchCriteria = {\r\n      conditions: [\r\n        {\r\n          field: 'uri',\r\n          operator: FilterOperator.EQUALS,\r\n          value: profileURL,\r\n        },\r\n      ],\r\n      threshold: 0,\r\n    };\r\n    if (!this.consentAgent) {\r\n      throw new Error('Consent Agent undefined');\r\n    }\r\n    const data = { preference: { _id: new ObjectId(preferenceId) } };\r\n\r\n    const profile = await this.consentAgent.findProfileAndPull(\r\n      'profiles',\r\n      criteria,\r\n      data,\r\n    );\r\n    if (!profile) throw new Error('Profile not found');\r\n\r\n    return profile.preference;\r\n  }\r\n\r\n  /**\r\n   * Return the profile's authorization\r\n   * @param profileURL - uri of the profile\r\n   * @return Promise<ProfileConfigurations>\r\n   */\r\n  async getConfigurationsFromProfile(\r\n    profileURL: string,\r\n  ): Promise<ProfileConfigurations> {\r\n    await this.prepare();\r\n    const criteria: SearchCriteria = {\r\n      conditions: [\r\n        {\r\n          field: 'uri',\r\n          operator: FilterOperator.EQUALS,\r\n          value: profileURL,\r\n        },\r\n      ],\r\n      threshold: 0,\r\n    };\r\n    if (!this.consentAgent) {\r\n      throw new Error('Consent Agent undefined');\r\n    }\r\n    const profiles = await this.consentAgent.findProfiles('profiles', criteria);\r\n    if (profiles.length === 0) throw new Error('Profile not found');\r\n\r\n    return profiles[0].configurations;\r\n  }\r\n\r\n  // Return the profile by uri\r\n  async getProfileByURL(uri: string): Promise<any> {\r\n    await this.prepare();\r\n    const criteria: SearchCriteria = {\r\n      conditions: [\r\n        {\r\n          field: 'uri',\r\n          operator: FilterOperator.EQUALS,\r\n          value: uri,\r\n        },\r\n      ],\r\n      threshold: 0,\r\n    };\r\n    if (!this.consentAgent) {\r\n      throw new Error('Consent Agent undefined');\r\n    }\r\n    const profile = await this.consentAgent.findProfile('profiles', criteria);\r\n    if (!profile) throw new Error('Profile not found');\r\n\r\n    return profile;\r\n  }\r\n\r\n  // Return the authorization of the profile\r\n  async getProfiles(): Promise<any> {\r\n    await this.prepare();\r\n    const criteria: SearchCriteria = {\r\n      conditions: [],\r\n      threshold: 0,\r\n    };\r\n\r\n    if (!this.consentAgent) {\r\n      throw new Error('Consent Agent undefined');\r\n    }\r\n\r\n    const profiles = await this.consentAgent.findProfiles('profiles', criteria);\r\n    if (profiles.length === 0) throw new Error('Profile not found');\r\n\r\n    return profiles;\r\n  }\r\n\r\n  // Return the authorization of the profile\r\n  async updateProfile(profileURL: string, data: ProfileDocument): Promise<any> {\r\n    await this.prepare();\r\n    const criteria: SearchCriteria = {\r\n      conditions: [\r\n        {\r\n          field: 'uri',\r\n          operator: FilterOperator.EQUALS,\r\n          value: profileURL,\r\n        },\r\n      ],\r\n      threshold: 0,\r\n    };\r\n    if (!this.consentAgent) {\r\n      throw new Error('Consent Agent undefined');\r\n    }\r\n\r\n    const profile = await this.consentAgent.findProfileAndUpdate(\r\n      'profiles',\r\n      criteria,\r\n      data,\r\n    );\r\n    if (!profile) throw new Error('Profile not found');\r\n\r\n    return profile;\r\n  }\r\n\r\n  /**\r\n   * Checks if the given parameters match the preferences of a profile.\r\n   * \r\n   * @param {string} profileId - The ID of the profile to check preferences for.\r\n   * @param {string} category - The category to match preferences against.\r\n   * @param {string} participant - The participant to match preferences against.\r\n   * @param {string} location - The location to match preferences against.\r\n   * @param {boolean} asDataProvider - Indicates if the check is for a data provider role.\r\n   * @param {boolean} asServiceProvider - Indicates if the check is for a service provider role.\r\n   * \r\n   * @returns {Promise<boolean>} A promise that resolves to a boolean indicating if the preferences match.\r\n   */\r\n  async checkPreferenceMatch(params: {\r\n    profileId: string;\r\n    category?: string;\r\n    participant?: string;\r\n    location?: string;\r\n    asDataProvider?: boolean;\r\n    asServiceProvider?: boolean;\r\n  }): Promise<boolean> {\r\n    const {\r\n      profileId,\r\n      category,\r\n      participant,\r\n      location,\r\n      asDataProvider,\r\n      asServiceProvider,\r\n    } = params;\r\n\r\n    if (category && participant) {\r\n      throw new Error(\r\n        'Cannot use both category and participant simultaneously.',\r\n      );\r\n    }\r\n\r\n    if (!category && !participant) {\r\n      throw new Error('At least one of category or participant must be true.');\r\n    }\r\n\r\n    if (asDataProvider && asServiceProvider) {\r\n      throw new Error(\r\n        'Cannot use both asDataProvider and asServiceProvider simultaneously.',\r\n      );\r\n    }\r\n\r\n    if (!asDataProvider && !asServiceProvider) {\r\n      throw new Error(\r\n        'At least one of asDataProvider or asServiceProvider must be true.',\r\n      );\r\n    }\r\n\r\n    await this.prepare();\r\n    const criteria: SearchCriteria = {\r\n      conditions: [\r\n        {\r\n          field: 'uri',\r\n          operator: FilterOperator.EQUALS,\r\n          value: profileId,\r\n        },\r\n      ],\r\n      threshold: 0,\r\n    };\r\n    if (!this.consentAgent) {\r\n      throw new Error('Consent Agent undefined');\r\n    }\r\n\r\n    if (participant) {\r\n      criteria.conditions.push({\r\n        field: 'preference.participant',\r\n        operator: FilterOperator.EQUALS,\r\n        value: participant,\r\n      });\r\n    }\r\n\r\n    if (category) {\r\n      criteria.conditions.push({\r\n        field: 'preference.category',\r\n        operator: FilterOperator.EQUALS,\r\n        value: category,\r\n      });\r\n    }\r\n\r\n    const profile = await this.consentAgent.findProfile('profiles', criteria);\r\n    if (!profile._id) return false;\r\n\r\n    let preference: ProfilePreference | undefined;\r\n    if (participant) {\r\n      preference = profile.preference.find(\r\n        (pref: any) => pref.participant === participant,\r\n      );\r\n    }\r\n\r\n    if (category) {\r\n      preference = profile.preference.find(\r\n        (pref: any) => pref.category === category,\r\n      );\r\n    }\r\n\r\n    if (preference) {\r\n      const currentDay = new Date().getDay().toString();\r\n      let isMatch = false;\r\n\r\n      if(asDataProvider && preference.asDataProvider){\r\n        isMatch = this.checkAuthorizationMatch(preference.asDataProvider, currentDay, location);\r\n      } else if(asServiceProvider && preference.asServiceProvider){\r\n        isMatch = this.checkAuthorizationMatch(preference.asServiceProvider, currentDay, location);\r\n      }\r\n\r\n      return isMatch;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * This function checks if the authorization matches the current day and location.\r\n   * \r\n   * @param authorization - The authorization object to check.\r\n   * @param currentDay - The current day of the week.\r\n   * @param location - The current location.\r\n   * @returns {boolean} - True if the authorization matches, false otherwise.\r\n   */\r\n  private checkAuthorizationMatch(authorization: {\r\n    authorizationLevel?: AuthorizationLevelEnum,\r\n    conditions?: Condition[]\r\n  }, currentDay: string, location: string | undefined): boolean {\r\n    if (\r\n      authorization.authorizationLevel === 'never'\r\n    ) {\r\n      return false; // Always false for \"never\" authorization\r\n    } else if (\r\n      authorization.authorizationLevel === 'always'\r\n    ) {\r\n      return true; // Always true for \"always\" authorization\r\n    } else if (authorization.authorizationLevel === 'conditional') {\r\n      // Check conditions for \"conditional\" authorization\r\n      if (authorization.conditions) {\r\n        return authorization.conditions.some((condition) => {\r\n          if (\r\n            condition.time &&\r\n            condition.time.dayOfWeek &&\r\n            condition.time.dayOfWeek.includes(currentDay)\r\n          ) {\r\n            const startTime = new Date(condition.time.startTime || '');\r\n            const endTime = new Date(condition.time.endTime || '');\r\n            const currentTime = new Date();\r\n            return currentTime >= startTime && currentTime <= endTime;\r\n          }\r\n\r\n          if (\r\n            condition.location &&\r\n            condition.location.countryCode === location\r\n          ) {\r\n            return true;\r\n          }\r\n          return false;\r\n        });\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n}\r\n","import { Request, Response } from 'express';\r\nimport { ConsentAgentRequestHandler } from './ConsentAgentHandler';\r\nimport { PreferencePayload, ProfileConfigurations } from './types';\r\nimport { Router } from 'express';\r\n\r\nconst router: Router = Router();\r\n\r\n/**\r\n * Handles the request to check if the preferences match the params.\r\n *\r\n * @param {Request} req - The incoming request object.\r\n * @param {Response} res - The response object to send back to the client.\r\n */\r\nrouter.get(\r\n  '/profile/:profileId/preferences/match',\r\n  async (req: Request, res: Response) => {\r\n    // #swagger.tags = ['Consent']\r\n    try {\r\n      const requestHandler = await ConsentAgentRequestHandler.retrieveService();\r\n      const { profileId } = req.params;\r\n      const {\r\n        category,\r\n        participant,\r\n        location,\r\n        asDataProvider,\r\n        asServiceProvider,\r\n      } = req.query;\r\n\r\n      const service = await requestHandler.checkPreferenceMatch({\r\n        profileId,\r\n        category: category?.toString(),\r\n        participant: participant?.toString(),\r\n        location: location?.toString(),\r\n        asDataProvider: asDataProvider === 'true',\r\n        asServiceProvider: asServiceProvider === 'true',\r\n      });\r\n      res.json(service);\r\n    } catch (error) {\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  },\r\n);\r\n\r\n/**\r\n * This function handles the request for consent recommendations.\r\n *\r\n * @param {Request} req - The request object.\r\n * @param {Response} res - The response object.\r\n */\r\nrouter.get(\r\n  '/profile/:profileId/recommendations/consent',\r\n  async (req: Request, res: Response) => {\r\n    // #swagger.tags = ['Consent']\r\n    try {\r\n      const requestHandler = await ConsentAgentRequestHandler.retrieveService();\r\n      const { profileId } = req.params;\r\n\r\n      const services =\r\n                await requestHandler.getConsentRecommendationFromProfile(profileId);\r\n      res.json(services);\r\n    } catch (error) {\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  },\r\n);\r\n\r\n/**\r\n * Get the data exchanges of a profile\r\n *\r\n * @param {Request} req\r\n * @param {Response} res\r\n */\r\nrouter.get(\r\n  '/profile/:profileId/recommendations/dataexchanges',\r\n  async (req: Request, res: Response) => {\r\n    // #swagger.tags = ['Consent']\r\n    try {\r\n      const requestHandler = await ConsentAgentRequestHandler.retrieveService();\r\n      const { profileId } = req.params;\r\n\r\n      const service =\r\n                await requestHandler.getDataExchangeRecommendationFromProfile(\r\n                  profileId,\r\n                );\r\n      res.json(service);\r\n    } catch (error) {\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  },\r\n);\r\n\r\n/**\r\n * Get the preferences of a profile\r\n *\r\n * @param {Request} req\r\n * @param {Response} res\r\n */\r\nrouter.get(\r\n  '/profile/:profileId/preferences',\r\n  async (req: Request, res: Response) => {\r\n    // #swagger.tags = ['Consent']\r\n    try {\r\n      const requestHandler = await ConsentAgentRequestHandler.retrieveService();\r\n      const { profileId } = req.params;\r\n\r\n      const service = await requestHandler.getPreferencesFromProfile(profileId);\r\n      res.json(service);\r\n    } catch (error) {\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  },\r\n);\r\n\r\n/**\r\n * Get the preference by ID of a profile\r\n *\r\n * @param {Request} req\r\n * @param {Response} res\r\n */\r\nrouter.get(\r\n  '/profile/:profileId/preferences/:preferenceId',\r\n  async (req: Request, res: Response) => {\r\n    // #swagger.tags = ['Consent']\r\n    try {\r\n      const requestHandler = await ConsentAgentRequestHandler.retrieveService();\r\n      const { profileId, preferenceId } = req.params;\r\n\r\n      const service =\r\n                await requestHandler.getPreferenceByIdFromProfile(\r\n                  profileId,\r\n                  preferenceId,\r\n                );\r\n      res.json(service);\r\n    } catch (error) {\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  },\r\n);\r\n\r\n/**\r\n * Adds a new preference to a profile.\r\n *\r\n * @param {Request} req - The incoming request object.\r\n * @param {Response} res - The response object to send back to the client.\r\n */\r\nrouter.post(\r\n  '/profile/:profileId/preferences',\r\n  async (req: Request, res: Response) => {\r\n    /*    #swagger.tags = ['Consent']\r\n              #swagger.requestBody = {\r\n                required: true,\r\n                content: {\r\n                    \"application/json\": {\r\n                        schema: {\r\n                            $ref: \"#/components/schemas/PreferencePayload\"\r\n                        }  \r\n                    }\r\n                }\r\n            } \r\n        */\r\n    try {\r\n      const requestHandler = await ConsentAgentRequestHandler.retrieveService();\r\n      const { profileId } = req.params;\r\n      const { preference } = req.body;\r\n\r\n      if (!preference.every((p: PreferencePayload) => p.participant || p.category)) {\r\n        throw new Error('Each preference must contain at least the field participant or category');\r\n      }\r\n\r\n      const service =\r\n                await requestHandler.addPreferenceToProfile(\r\n                  profileId,\r\n                  preference,\r\n                );\r\n\r\n      res.status(201).json(service);\r\n    } catch (error) {\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  },\r\n);\r\n\r\n/**\r\n * Handles the update of a specific preference within a profile.\r\n *\r\n * @param {Request} req - The incoming request object.\r\n * @param {Response} res - The response object to send back to the client.\r\n */\r\nrouter.put(\r\n  '/profile/:profileId/preferences/:preferenceId',\r\n  async (req: Request, res: Response) => {\r\n    // #swagger.tags = ['Consent']\r\n    try {\r\n      const requestHandler = await ConsentAgentRequestHandler.retrieveService();\r\n      const { profileId, preferenceId } = req.params;\r\n\r\n      const service =\r\n                await requestHandler.updatePreferenceByIdFromProfile(\r\n                  profileId,\r\n                  preferenceId,\r\n                  req.body,\r\n                );\r\n      res.json(service);\r\n    } catch (error) {\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  },\r\n);\r\n\r\n/**\r\n * Handles the deletion of a specific preference from a profile.\r\n *\r\n * @param {Request} req - The incoming request object.\r\n * @param {Response} res - The response object to send back to the client.\r\n */\r\nrouter.delete(\r\n  '/profile/:profileId/preferences/:preferenceId',\r\n  async (req: Request, res: Response) => {\r\n    // #swagger.tags = ['Consent']\r\n    try {\r\n      const requestHandler = await ConsentAgentRequestHandler.retrieveService();\r\n      const { profileId, preferenceId } = req.params;\r\n\r\n      const service =\r\n                await requestHandler.deletePreferenceByIdFromProfile(\r\n                  profileId,\r\n                  preferenceId,\r\n                );\r\n      res.json(service);\r\n    } catch (error) {\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  },\r\n);\r\n\r\n/**\r\n * Get the configurations of the profile\r\n *\r\n * @param {Request} req\r\n * @param {Response} res\r\n */\r\nrouter.get(\r\n  '/profile/:profileId/configurations',\r\n  async (req: Request, res: Response) => {\r\n    // #swagger.tags = ['Consent']\r\n    try {\r\n      const requestHandler = await ConsentAgentRequestHandler.retrieveService();\r\n      const { profileId } = req.params;\r\n\r\n      const service =\r\n                await requestHandler.getConfigurationsFromProfile(\r\n                  profileId,\r\n                );\r\n      res.json(service);\r\n    } catch (error) {\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  },\r\n);\r\n\r\n/**\r\n * Update the configurations\r\n *\r\n * @param {Request} req - The incoming request object.\r\n * @param {Response} res - The response object to send back to the client.\r\n * @param {ProfileConfigurations} req.body.configurations - The configurations to be updated.\r\n */\r\nrouter.put(\r\n  '/profile/:profileId/configurations',\r\n  async (req: Request, res: Response) => {\r\n    /*    #swagger.tags = ['Consent']\r\n              #swagger.requestBody = {\r\n                required: true,\r\n                content: {\r\n                    \"application/json\": {\r\n                        schema: {\r\n                            $ref: \"#/components/schemas/ProfileConfigurations\"\r\n                        }  \r\n                    }\r\n                }\r\n            } \r\n        */\r\n    try {\r\n      const requestHandler = await ConsentAgentRequestHandler.retrieveService();\r\n      const { profileId } = req.params;\r\n      const configurations: ProfileConfigurations = req.body.configurations;\r\n\r\n      const services =\r\n                await requestHandler.updateProfile(\r\n                  profileId,\r\n                  {\r\n                    uri: profileId,\r\n                    configurations,\r\n                  },\r\n                );\r\n      res.json(services);\r\n    } catch (error) {\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  },\r\n);\r\n\r\n/**\r\n * Get a profile\r\n *\r\n * @param {Request} req\r\n * @param {Response} res\r\n */\r\nrouter.get(\r\n  '/profile/:profileId',\r\n  async (req: Request, res: Response) => {\r\n    // #swagger.tags = ['Consent']\r\n    try {\r\n      const requestHandler = await ConsentAgentRequestHandler.retrieveService();\r\n      const { profileId } = req.params;\r\n      const services =\r\n                await requestHandler.getProfileByURL(\r\n                  profileId,\r\n                );\r\n      res.json(services);\r\n    } catch (error) {\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  },\r\n);\r\n\r\n/**\r\n * Get all profiles\r\n *\r\n * @param {Request} req\r\n * @param {Response} res\r\n */\r\nrouter.get(\r\n  '/profile/',\r\n  async (req: Request, res: Response) => {\r\n    // #swagger.tags = ['Consent']\r\n    try {\r\n      const requestHandler = await ConsentAgentRequestHandler.retrieveService();\r\n      const services =\r\n                await requestHandler.getProfiles();\r\n      res.json(services);\r\n    } catch (error) {\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  },\r\n);\r\n\r\nexport default router;\r\n","import mongoose, { Document, Model, Schema, Connection } from 'mongoose';\r\nimport { DataProvider } from './DataProvider';\r\nimport {\r\n  FilterOperator,\r\n  SearchCriteria,\r\n  FilterCondition,\r\n  DataProviderConfig,\r\n} from './types';\r\nimport { Logger } from './Logger';\r\nimport { setTimeout, clearTimeout } from 'timers';\r\nimport { ProfileSchema } from './Profile';\r\n\r\ntype DocumentChangeHandler = (collectionName: string, document: any) => void;\r\n\r\nclass MongooseInterceptor {\r\n  private static instance: MongooseInterceptor;\r\n  private callbacks: Map<string, DocumentChangeHandler[]>;\r\n\r\n  private constructor() {\r\n    this.callbacks = new Map();\r\n    ['insert', 'update', 'delete'].forEach((op) => {\r\n      this.callbacks.set(op, []);\r\n    });\r\n  }\r\n\r\n  static getInstance(): MongooseInterceptor {\r\n    if (!MongooseInterceptor.instance) {\r\n      MongooseInterceptor.instance = new MongooseInterceptor();\r\n    }\r\n    return MongooseInterceptor.instance;\r\n  }\r\n\r\n  public addCallback(\r\n    changeType: string,\r\n    callback: DocumentChangeHandler,\r\n  ): void {\r\n    const callbacks = this.callbacks.get(changeType) || [];\r\n    callbacks.push(callback);\r\n    this.callbacks.set(changeType, callbacks);\r\n  }\r\n\r\n  public notifyCallbacks(\r\n    changeType: string,\r\n    collectionName: string,\r\n    document: any,\r\n  ): void {\r\n    const callbacks = this.callbacks.get(changeType) || [];\r\n    callbacks.forEach((callback) => callback(collectionName, document));\r\n  }\r\n}\r\n\r\nexport class MongooseProvider extends DataProvider {\r\n  findAll(): Promise<any[]> {\r\n    throw new Error('Method not implemented.');\r\n  }\r\n  findOne(criteria: SearchCriteria): Promise<any> {\r\n    throw new Error('Method not implemented.');\r\n  }\r\n  findOneAndUpdate(criteria: SearchCriteria, data: any): Promise<any> {\r\n    throw new Error('Method not implemented.');\r\n  }\r\n  findOneAndPush(criteria: SearchCriteria, data: any): Promise<any> {\r\n    throw new Error('Method not implemented.');\r\n  }\r\n  findOneAndPull(criteria: SearchCriteria, data: any): Promise<any> {\r\n    throw new Error('Method not implemented.');\r\n  }\r\n  private static connections: Map<string, Connection | undefined> = new Map();\r\n  private static externalModels: Map<string, Schema> = new Map();\r\n  private static instances: Map<string, MongooseProvider> = new Map();\r\n  private connection?: Connection;\r\n  private model!: Model<any>;\r\n  private dbName: string;\r\n  private connectionPromise?: Promise<void>;\r\n  private url: string;\r\n\r\n  private mongoosePromise: Promise<void>;\r\n  private mongoosePromiseResolve: (() => void) | null = null;\r\n\r\n  constructor(config: DataProviderConfig) {\r\n    super(config.source);\r\n    this.dbName = config.dbName;\r\n    this.url = config.url;\r\n    this.mongoosePromise = new Promise((resolve) => {\r\n      this.mongoosePromiseResolve = resolve;\r\n    });\r\n    MongooseProvider.instances.set(config.source, this);\r\n  }\r\n\r\n  static setCollectionModel<T extends Document>(\r\n    source: string,\r\n    schema: Schema,\r\n  ): void {\r\n    schema.post('save', (doc: Document) => {\r\n      const provider = MongooseProvider.instances.get(source);\r\n      if (provider) {\r\n        provider.notifyDataChange('dataInserted', {\r\n          source,\r\n          fullDocument: doc,\r\n        });\r\n      }\r\n    });\r\n\r\n    schema.post('insertMany', (docs: Document[]) => {\r\n      const provider = MongooseProvider.instances.get(source);\r\n      if (provider) {\r\n        docs.forEach((doc) => {\r\n          provider.notifyDataChange('dataInserted', {\r\n            source,\r\n            fullDocument: doc,\r\n          });\r\n        });\r\n      }\r\n    });\r\n\r\n    schema.post(['updateOne', 'findOneAndUpdate'], (doc: Document) => {\r\n      const provider = MongooseProvider.instances.get(source);\r\n      if (provider) {\r\n        provider.notifyDataChange('dataUpdated', {\r\n          source,\r\n          updateDescription: {\r\n            updatedFields: doc,\r\n          },\r\n        });\r\n      }\r\n    });\r\n\r\n    schema.post(['deleteOne', 'findOneAndDelete'], (doc: Document) => {\r\n      const provider = MongooseProvider.instances.get(source);\r\n      if (provider) {\r\n        provider.notifyDataChange('dataDeleted', {\r\n          source,\r\n          documentKey: { _id: doc._id },\r\n        });\r\n      }\r\n    });\r\n\r\n    MongooseProvider.externalModels.set(source, schema);\r\n    Logger.info(`External schema set for collection: ${source}`);\r\n  }\r\n\r\n  static getCollectionSchema(source: string): Schema | undefined {\r\n    return MongooseProvider.externalModels.get(source);\r\n  }\r\n\r\n  public getMongoosePromise(): Promise<void> {\r\n    return this.mongoosePromise;\r\n  }\r\n\r\n  async ensureReady(): Promise<void> {\r\n    if (mongoose.connection.readyState !== 1) {\r\n      Logger.info('Connecting to Mongoose...');\r\n      try {\r\n        if (mongoose.connection.readyState === 0) {\r\n          await mongoose.connect(this.url + '/' + this.dbName, {\r\n            retryWrites: true,\r\n            serverSelectionTimeoutMS: 5000,\r\n            family: 4,\r\n          });\r\n          if (this.mongoosePromiseResolve) {\r\n            this.mongoosePromiseResolve();\r\n          } else {\r\n            throw new Error('Mongoose promise undefined');\r\n          }\r\n        }\r\n        mongoose.connection.on('disconnected', () => {\r\n          Logger.warn('Mongoose disconnected');\r\n        });\r\n      } catch (error) {\r\n        Logger.error(\r\n          `Error during Mongoose connection: ${(error as Error).message}`,\r\n        );\r\n        throw error;\r\n      }\r\n    }\r\n\r\n    const schema = MongooseProvider.getCollectionSchema(this.dataSource);\r\n    if (schema) {\r\n      try {\r\n        this.model = mongoose.model(this.dataSource);\r\n      } catch {\r\n        this.model = mongoose.model(this.dataSource, schema);\r\n      }\r\n    } else {\r\n      this.model = mongoose.model(this.dataSource, ProfileSchema);\r\n    }\r\n  }\r\n\r\n  setupHooks(): void {\r\n    this.model.schema.post('save', (doc: Document) => {\r\n      this.notifyDataChange('dataInserted', {\r\n        source: this.dataSource,\r\n        fullDocument: doc,\r\n      });\r\n    });\r\n\r\n    this.model.schema.post('insertMany', (docs: Document[]) => {\r\n      docs.forEach((doc) => {\r\n        this.notifyDataChange('dataInserted', {\r\n          source: this.dataSource,\r\n          fullDocument: doc,\r\n        });\r\n      });\r\n    });\r\n\r\n    this.model.schema.post(\r\n      ['updateOne', 'findOneAndUpdate'],\r\n      (doc: Document) => {\r\n        this.notifyDataChange('dataUpdated', {\r\n          source: this.dataSource,\r\n          updateDescription: {\r\n            updatedFields: doc,\r\n          },\r\n        });\r\n      },\r\n    );\r\n\r\n    this.model.schema.post(\r\n      ['deleteOne', 'findOneAndDelete'],\r\n      (doc: Document) => {\r\n        this.notifyDataChange('dataDeleted', {\r\n          source: this.dataSource,\r\n          documentKey: { _id: doc._id },\r\n        });\r\n      },\r\n    );\r\n  }\r\n\r\n  protected makeQuery(conditions: FilterCondition[]): Record<string, any> {\r\n    return conditions.reduce((query, condition) => {\r\n      switch (condition.operator) {\r\n        case FilterOperator.IN:\r\n          return {\r\n            ...query,\r\n            [condition.field]: { $in: condition.value },\r\n          };\r\n        case FilterOperator.EQUALS:\r\n          return {\r\n            ...query,\r\n            [condition.field]: condition.value,\r\n          };\r\n        case FilterOperator.GT:\r\n          return {\r\n            ...query,\r\n            [condition.field]: { $gt: condition.value },\r\n          };\r\n        case FilterOperator.LT:\r\n          return {\r\n            ...query,\r\n            [condition.field]: { $lt: condition.value },\r\n          };\r\n        case FilterOperator.CONTAINS:\r\n          return {\r\n            ...query,\r\n            [condition.field]: {\r\n              $in: Array.isArray(condition.value)\r\n                ? condition.value\r\n                : [condition.value],\r\n            },\r\n          };\r\n        case FilterOperator.REGEX:\r\n          return {\r\n            ...query,\r\n            [condition.field]: {\r\n              $in: Array.isArray(condition.value)\r\n                ? condition.value.map((val) => new RegExp(val, 'i'))\r\n                : [new RegExp(condition.value, 'i')],\r\n            },\r\n          };\r\n        default:\r\n          throw new Error(`Unsupported operator: ${condition.operator}`);\r\n      }\r\n    }, {});\r\n  }\r\n\r\n  async create(data: Document): Promise<Document> {\r\n    try {\r\n      /*\r\n      if (!this.model || !this.connection?.readyState) {\r\n        await this.ensureReady();\r\n      }\r\n      */\r\n      return await this.model.create(data);\r\n    } catch (error) {\r\n      Logger.error(\r\n        `Error during document insertion: ${(error as Error).message}`,\r\n      );\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async delete(id: string): Promise<boolean> {\r\n    try {\r\n      const result = await this.model.deleteOne({\r\n        _id: new mongoose.Types.ObjectId(id),\r\n      });\r\n\r\n      if (result.deletedCount === 0) {\r\n        Logger.warn(`No document found with id: ${id}`);\r\n        return false;\r\n      }\r\n\r\n      Logger.info(`Document with id: ${id} successfully deleted`);\r\n      return true;\r\n    } catch (error) {\r\n      Logger.error(\r\n        `Error during document deletion: ${(error as Error).message}`,\r\n      );\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async find(criteria: SearchCriteria): Promise<[]> {\r\n    const query = this.makeQuery(criteria.conditions);\r\n    const data = await this.model\r\n      .find(query)\r\n      .limit(criteria.limit || 0)\r\n      .exec();\r\n    return data.map((item) => {\r\n      if (item._id) {\r\n        const { _id, ...rest } = item.toObject();\r\n        return {\r\n          _id: (_id as mongoose.Types.ObjectId).toString(),\r\n          ...rest,\r\n        };\r\n      }\r\n      return item.toObject();\r\n    }) as [];\r\n  }\r\n\r\n  async update(criteria: SearchCriteria, data: unknown): Promise<boolean> {\r\n    try {\r\n      const updateData = data as Record<string, any>;\r\n      const query = this.makeQuery(criteria.conditions);\r\n      const result = await this.model\r\n        .updateOne(query, {\r\n          $set: updateData,\r\n        })\r\n        .exec();\r\n      if (result.matchedCount === 0) {\r\n        Logger.warn(`No document found matching the criteria`);\r\n        return false;\r\n      }\r\n      if (result.modifiedCount === 0) {\r\n        Logger.info(`No changes made to document`);\r\n        return false;\r\n      }\r\n      Logger.info(`Document successfully updated`);\r\n      return true;\r\n    } catch (error) {\r\n      Logger.error(`Error during document update: ${(error as Error).message}`);\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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","names":["mongoose","CAECode","import_path","path","_a","_a","import_express","router","import_mongodb","MongoInterceptor","import_mongodb","axios","import_mongodb","import_express","router","import_mongoose","mongoose"]}